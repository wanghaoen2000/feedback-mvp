# 批量处理功能技术调研结果

---

## 1. 任务编号的前端处理

**state 变量名：**
- `startNumber`: 起始编号（字符串类型）
- `endNumber`: 结束编号（字符串类型）

**位置：** `BatchProcess.tsx` 第 255-256 行
```typescript
const [startNumber, setStartNumber] = useState("");
const [endNumber, setEndNumber] = useState("");
```

**传递给后端的参数名：**
- `startNumber`: 起始任务编号（转换为数字后传递）
- `endNumber`: 结束任务编号（转换为数字后传递）

**位置：** `BatchProcess.tsx` 第 782-784 行
```typescript
body: JSON.stringify({
  startNumber: start,  // parseInt(startNumber)
  endNumber: end,      // parseInt(endNumber)
  ...
})
```

---

## 2. 任务编号的后端处理

**接收参数：** `batchRoutes.ts` 第 182-184 行
```typescript
const { startNumber, endNumber, ... } = req.body;
```

**任务列表生成：** `batchRoutes.ts` 第 221-225 行
```typescript
const taskNumbers: number[] = [];
for (let i = start; i <= end; i++) {
  taskNumbers.push(i);
}
```
是的，就是简单的 `for` 循环生成连续编号数组。

**任务编号注入路书：** `batchRoutes.ts` 第 379-380 行
```typescript
// user message 中注入任务编号
let userMessage = `这是任务编号 ${taskNumber}，请按照路书要求生成内容。`;
```
**注意：路书本身不做占位符替换**，任务编号是通过 user message 告知 AI 的。

---

## 3. 并发池与任务执行

**并发池接收的任务格式：** 数字数组 `number[]`
```typescript
const pool = new ConcurrencyPool<BatchTaskResult>(concurrencyNum);
pool.addTasks(taskNumbers);  // taskNumbers 是 [1, 2, 3, ...] 这样的数组
```

**taskId 的确定：** 就是任务编号本身（`taskNumber`）

**任务编号使用位置：**
1. **路书/消息构建**：`这是任务编号 ${taskNumber}，请按照路书要求生成内容。`
2. **文件命名**：`${prefix}${taskNumStr}.docx`（taskNumStr 是补零后的编号）
3. **独立文件匹配**：`const independentFile = independentFiles?.[taskNumber]`
4. **SSE 事件**：所有事件都包含 `taskNumber` 字段
5. **日志输出**：`[BatchRoutes] 任务 ${taskNumber} 开始执行`

---

## 4. 文件命名

**默认命名方式（prefix）：**
```typescript
const taskNumStr = taskNumber.toString().padStart(2, '0');  // 补零到2位
const prefix = filePrefix.trim() || '任务';
filename = `${prefix}${taskNumStr}.docx`;  // 例如：任务01.docx, 任务02.docx
```

**自定义命名方式（custom）：**
- 前端解析用户输入的文本，生成 `parsedNames: Map<number, string>`
- 传递给后端：`customFileNames: Object.fromEntries(parsedNames)`
- 后端使用：`const customName = customFileNames?.[taskNumber]`
- 如果有自定义名：`filename = \`${customName}.docx\``

**AI 自主命名方式（ai_auto，仅 ai_code 模式）：**
- AI 在生成的代码中自定义文件名
- 如果 AI 没有自定义（默认 output.docx），回退到前缀+编号

---

## 总结表格

| 问题 | 答案 |
|------|------|
| 前端 state 变量名 | `startNumber`, `endNumber` |
| API 请求参数名 | `startNumber`, `endNumber` |
| 后端生成任务列表 | `for (let i = start; i <= end; i++)` 循环 |
| 路书占位符替换 | **没有**，任务编号通过 user message 告知 AI |
| 并发池任务格式 | `number[]` 数字数组 |
| taskId | 就是 `taskNumber` |
| 文件名拼接 | `${prefix}${taskNumStr}.docx`，taskNumStr 补零到 2 位 |
| 自定义命名 | `customFileNames[taskNumber]` 映射 |

---

## 实现"指定任务"功能的关键改动点

如果要实现"指定任务"功能，关键改动点是：
1. **前端**：将 `startNumber/endNumber` 改为支持任意编号列表（如 `1,3,5` 或 `1-3,7,9-11`）
2. **后端**：将 `for` 循环改为接收任意 `taskNumbers` 数组
3. **其他逻辑**（文件命名、独立文件匹配等）无需改动，因为它们都是基于 `taskNumber` 的
