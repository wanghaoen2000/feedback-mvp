# 学情反馈系统 — 技术说明书（白话版）

> 这份文档用最直白的语言解释这个系统里到底发生了什么。
> 专业术语会用**加粗**标出，后面紧跟大白话解释。

---

## 一、这个系统是干嘛的？

一句话：**老师上完课，把课堂笔记和录音往系统里一丢，系统自动帮你写好 5 份文档，还帮你传到网盘上。**

具体来说，系统能做这些事：

1. **写学情反馈** — 就是那种发到家长群里的课后总结，"您家孩子今天学了什么、表现怎样、哪里需要加强"
2. **写复习文档** — 帮学生整理今天课上的重点知识，方便回家复习
3. **出测试题** — 根据今天讲的内容自动出一套练习题，带答案
4. **提取课后信息** — 把"今天布置了什么作业、下次课讲什么"这些信息自动摘出来
5. **画气泡图** — 一张图片，用大大小小的气泡展示学生各个知识点掌握得怎么样

除了这个核心功能，系统还能：
- **管作业** — 老师说一句"小明今天阅读理解错了3题"，AI 自动帮你整理成规范的记录
- **批作业** — 上传学生作业（文字或照片），AI 帮你批改
- **打分** — 一周结束了，AI 帮你给每个学生打个总结评分
- **催作业** — 一键生成催学生交作业的文案

---

## 二、系统的"身体构造"

### 2.1 前端和后端 — 餐厅的前厅和后厨

整个系统分两大块：

**前端（Frontend）**，就是你打开网页看到的那个界面 — 按钮、输入框、Tab 页。你可以把它想象成餐厅的**前厅**，客人（老师）在这里点菜、看菜单。

**后端（Backend）**，就是藏在服务器上的程序逻辑 — 接收你的请求，调用 AI，生成文档，上传网盘。这就是餐厅的**后厨**，厨师在这里做菜，客人看不到，但所有活儿都在这干。

它们之间怎么沟通呢？前端说"我要一份学情反馈"，后端说"收到，给你做"。做好了，后端把结果传回前端，你就在页面上看到了。

```
你看到的网页（前端）
    ↕ 互相传话
藏在服务器里的程序（后端）
    ↕ 去拿数据 / 存数据
数据库 + 网盘
```

### 2.2 数据库 — 系统的"记忆"

**数据库（Database）** 就是系统的记忆本。所有需要记住的东西都存在这里：用户信息、学生名单、作业记录、历史任务……

你可以把它想象成一个超级 Excel 表格。系统里有 13 张这样的"表格"，每张表格记不同的东西：

| 表格名 | 记什么 |
|--------|--------|
| users | 谁在用这个系统（用户账号信息） |
| user_config | 每个用户自己的设置（用什么 AI 模型、API 密钥等） |
| hw_students | 学生花名册（名字、状态、计划类型） |
| hw_entries | 作业输入队列（老师说的话 → AI 处理后的结果） |
| background_tasks | 后台正在干的活（反馈生成任务的进度） |
| batch_tasks | 批量任务（一次性生成很多份文档） |
| correction_tasks | 批改任务记录 |
| grading_tasks | 打分任务记录 |
| reminder_tasks | 催作业任务记录 |
| google_tokens | 每个用户连接 Google 网盘的"钥匙" |
| system_config | 系统级别的全局设置 |

关键规则：**每个用户只能看到自己的数据**。张老师看不到李老师的学生，李老师也看不到张老师的作业记录。这叫**多租户隔离（Multi-tenant Isolation）**，就好比虽然大家住同一栋楼，但每家有自己的门锁，你进不了别人家。

### 2.3 用了哪些技术（技术栈）

**技术栈（Tech Stack）** 就是"我们用了哪些工具来搭这个系统"。就像盖房子要选砖头、水泥、钢筋一样，做软件也要选一堆工具。

| 工具 | 干什么用 | 大白话 |
|------|---------|--------|
| **React** | 做前端界面 | 就是帮我们画网页的工具，点按钮、切换 Tab 这些交互都靠它 |
| **TypeScript** | 写代码的语言 | JavaScript 的"加强版"，多了类型检查，能在写代码的时候就发现一些错误，而不是上线了才发现 |
| **Vite** | 前端打包工具 | 把一堆零散的代码文件打包成浏览器能运行的格式，就像把一堆食材加工成盒饭 |
| **TailwindCSS** | 写样式 | 控制网页长什么样——颜色、大小、间距，就是"化妆师" |
| **shadcn/ui** | 现成的 UI 组件 | 别人做好的按钮、弹窗、输入框，我们直接拿来用，不用自己从零画 |
| **Express** | 后端框架 | 后端程序的"骨架"，帮我们接收请求、返回结果 |
| **tRPC** | 前后端通信 | 前端和后端"对话"的方式，特点是**类型安全** — 就是前端问的问题和后端给的答案格式必须对得上，对不上直接报错，避免鸡同鸭讲 |
| **MySQL** | 数据库 | 就是前面说的"记忆本"，专门存数据的软件 |
| **Drizzle ORM** | 操作数据库的工具 | 让我们用 TypeScript 代码来读写数据库，不用手写 SQL（一种专门操作数据库的语言） |
| **Google Drive API** | 连接 Google 网盘 | 让系统能自动把生成的文档传到你的 Google Drive 里 |
| **@resvg/resvg-js** | 画气泡图 | 把 SVG（一种矢量图格式）变成 PNG（普通图片），用来生成气泡图 |
| **esbuild** | 后端打包工具 | 把后端代码也打包成能直接运行的文件，速度非常快 |

---

## 三、核心功能是怎么工作的？

### 3.1 学情反馈生成 — 系统的"主菜"

这是整个系统最核心的功能。来，我们从头到尾走一遍：

**第 1 步：你输入信息**

在网页上填写：学生叫什么、第几次课、课堂笔记、录音转文字。然后点"生成"。

**第 2 步：系统创建一个"后台任务"**

你点了生成之后，系统在数据库里记下一条："有个活要干，还没开始"。这就是**后台任务（Background Task）**。

为什么要这么做？因为 AI 生成文档很慢，可能要几分钟。如果你在网页上干等着，万一手机锁屏了、网断了，前面的工作就白费了。所以系统先把任务"登记入册"，然后在后台慢慢干，你关掉网页也不影响。就像你在餐厅点完菜，可以去逛街，菜做好了服务员会通知你。

**第 3 步：AI 依次生成 5 份文档**

后台开始一步步干活：

```
第 1 步：写学情反馈
  系统把你的课堂笔记 + 录音转文字 + 上次反馈 打包发给 AI
  AI 读完这些，写出一份学情反馈（纯文字，可以直接复制到微信群）

第 2 步：写复习文档
  基于刚才的反馈内容，AI 提取知识点，写成一份 Word 文档

第 3 步：出测试题
  AI 根据内容出练习题 + 答案，也生成 Word 文档

第 4 步：提取课后信息
  AI 把"布置了什么作业、有什么难点、下次讲什么"摘出来

第 5 步：画气泡图
  AI 先生成一份描述（哪些知识点、掌握程度如何）
  系统把它画成一张带气泡的图片
```

每一步做完，系统都把结果存到数据库里（记在 `stepResults` 字段），并且上传到 Google Drive。

**第 4 步：你看到结果**

前端每隔几秒问一下后端："那个任务做完了吗？"（这叫**轮询，Polling**，就是不停地去问"好了没？好了没？"）。等后端说"做完了"，前端就把结果显示出来——5 个文件的链接，点击就能打开。

### 3.2 SSE 流式生成 — "直播做菜"

有些场景下，系统不是默默在后台做完再告诉你，而是**边做边给你看**。比如小班课的反馈生成，你能实时看到"已生成 500 字……已生成 1200 字……"。

这用到了一个叫 **SSE（Server-Sent Events，服务器推送事件）** 的技术。

大白话：普通的方式是你问一句、服务器答一句，一来一回。SSE 就像开了一条"直播通道" — 服务器那边有新内容了，直接推给你，你不用一直问。就像看视频直播，主播不是等你每次点一下才播下一帧，而是持续不断地把画面推给你。

```
普通方式：
  你："好了吗？" → 服务器："还没"
  你："好了吗？" → 服务器："还没"
  你："好了吗？" → 服务器："好了！"

SSE 方式：
  你："开始吧" →
  服务器："来了来了，第1段……"
  服务器："第2段……"
  服务器："第3段……"
  服务器："全部完成！"
```

### 3.3 作业管理 — "迭代更新"的学生档案

作业管理的核心概念叫**迭代更新**。

传统做法：每次课后记一条新笔记，最后你要翻过去所有笔记才知道学生现在啥状态。

我们的做法：系统维护一份**始终是最新的**学生状态文档。每次有新信息进来，AI 不是另起一页，而是**在原来那份文档上修改更新**。就像你有一份简历，每次换工作不是重新写一份，而是在原来那份上改。

流程是这样的：

```
老师说了一句话（语音或文字输入）
  ↓
系统创建一个"待处理条目"
  ↓
AI 读取这个学生现有的状态文档 + 老师新说的内容
  ↓
AI 生成更新后的状态文档（把新信息融进去）
  ↓
进入"预入库"队列 — 先让老师看看 AI 处理得对不对
  ↓
老师确认 → 正式入库 → 学生状态文档更新为最新版
```

为什么叫"预入库"？因为 AI 有时候会理解错，所以给老师一个检查的机会。就像餐厅上菜前，厨师先让领班看一眼对不对，再端给客人。

### 3.4 作业批改 — AI 帮你改作业

```
老师上传学生作业（文字 or 照片）
  ↓
AI 读取这个学生的现有状态（上下文），知道这学生最近在学什么
  ↓
AI 输出两样东西：
  ① 给学生的批改结果（"你这题错在哪、怎么改"）
  ② 给作业管理的状态更新（"这个学生推断题还是不行"）
  ↓
状态更新自动推送到作业管理系统 → 学生档案自动更新
```

这里有个巧妙的设计：批改完自动更新学生档案，老师不用手动去作业管理里再记一遍。几个功能模块之间是**打通的**。

### 3.5 一键打分 — 周末算总账

```
老师设定：这周一到周五的作业表现打分
  ↓
阶段一：AI 读取所有学生这周的状态记录，生成一份总结性打分
  ↓
老师可以看看改改（比如 AI 给严了或给松了）
  ↓
阶段二：系统把打分结论拆开，分发给每个学生
  ↓
AI 把每个学生的打分结论融入各自的状态文档
  ↓
所有学生的档案都更新了
```

这里有个关键词叫**并发（Concurrency）**。就是说系统不是一个一个学生排队处理，而是同时处理好多个。就像一个老师改作业只能一本一本改，但 AI 可以同时改 20 本甚至 100 本，大大加快速度。

### 3.6 批量处理 — 一次干很多份

有时候老师需要一次性生成 50 份词汇表或练习册。系统支持**批量处理**：

```
输入：编号 1-50 + 统一的指令模板
  ↓
系统创建 50 个子任务，同时跑（最多 100 个并发）
  ↓
每个子任务独立调用 AI → 生成文档 → 上传网盘
  ↓
网页上实时显示每个任务的进度
```

---

## 四、Google Drive 集成 — 文档往哪放？

生成的文档不是存在我们自己的服务器上，而是直接传到老师的 **Google Drive（谷歌网盘）** 里。

### 连接过程

第一次使用时，老师需要**授权（Authorization）**：系统会弹出一个 Google 的登录页面，老师登录并同意"允许这个系统访问你的 Google Drive"。

这个过程用的是 **OAuth（开放授权协议）**。大白话：你不需要把 Google 密码告诉我们的系统，而是通过 Google 官方页面授权。Google 会给我们一把"临时钥匙"（叫 **token，令牌**），我们拿着这把钥匙就能帮你上传文件，但干不了别的事（比如读你的邮件）。

```
老师点击"连接Google Drive"
  ↓
跳转到 Google 登录页面 → 老师同意授权
  ↓
Google 给系统一把"临时钥匙"（access_token + refresh_token）
  ↓
系统把这把钥匙存到数据库里
  ↓
以后每次上传文件，系统拿着这把钥匙去开门
  ↓
钥匙过期了？系统自动用 refresh_token 换一把新的
```

### 上传过程

```
系统拿着钥匙 → 按路径找到目标文件夹（没有就自动创建）→ 上传文件
```

这里有个小细节：如果有很多任务同时上传，可能会"撞车" — 两个任务同时发现文件夹不存在，然后各自创建了一个同名文件夹。系统做了**并发去重**处理：第一个任务说"我来建文件夹"，第二个任务说"行，我等你建好我直接用"。

---

## 五、AI 调用 — 系统的"大脑"

系统本身不会"思考"，所有智能工作都是交给外部的 **AI 大模型（Large Language Model, LLM）** 来做的。

你可以这么理解：我们的系统是一个"组织者"，它知道该问什么问题、按什么顺序问、拿到答案后怎么处理。但真正"动脑子"写反馈、出题目、批作业的，是外面的 AI 服务。

### 怎么调用 AI？

系统给 AI 发一个请求，大概长这样：

```
系统提示词（你是一个托福阅读教师的助手，请按以下规范生成反馈……）
  +
用户输入（学生叫小明，第12次课，今天学了推断题……）
  +
历史上下文（上次反馈是……学生目前状态是……）
  ↓
AI 返回生成的文本
```

**系统提示词（System Prompt）** 就是给 AI 的"工作说明书"，告诉它你是谁、该怎么做、格式要求是什么。不同的步骤有不同的提示词 — 生成反馈用一套，出测试题用另一套。

### 流式调用 vs 非流式调用

- **非流式**：系统发请求，等 AI 全部写完再一次性返回。适合后台任务。
- **流式（Streaming）**：AI 边写边传，系统边收边给你看。就像打字聊天，对方一个字一个字蹦出来，而不是憋半天突然甩一大段。适合需要实时看进度的场景。

### 每个用户可以配置自己的 AI

每个老师可以在设置里填自己的 **API Key（接口密钥）**。这就像每个人有自己的电话卡，打 AI 的"电话"用自己的额度，互不影响。老师还可以选择不同的 AI 模型、不同的供应商。

---

## 六、用户认证 — 你是谁？

### 登录过程

系统怎么知道你是谁？通过 **OAuth 登录**（和前面 Google Drive 授权是类似的原理）：

```
你点"登录" → 跳转到认证服务的页面 → 输入账号密码 → 认证成功
  ↓
认证服务告诉我们的系统："这个人是张老师，身份ID是xxx"
  ↓
系统生成一个 **Session Token（会话令牌）**
  — 就是一张"临时通行证"，证明你已经登录了
  ↓
通行证存在浏览器的 **Cookie（小饼干？其实是浏览器的小型存储区）** 里
  ↓
之后你每次操作，浏览器自动带上这张通行证
  ↓
系统看到通行证，就知道"哦，这是张老师"
```

### 权限等级

系统里有三种"门禁级别"：

| 级别 | 谁能进 | 能干什么 |
|------|--------|---------|
| 公开接口 | 任何人 | 检查系统是否活着（健康检查） |
| 普通用户接口 | 登录了的老师 | 生成反馈、管作业、批改……所有正常功能 |
| 管理员接口 | 管理员（admin） | 管理用户、设置邮箱白名单、伪装成其他用户查看数据 |

### 管理员伪装模式

管理员可以"变身"成任何一个老师，看到那个老师看到的所有数据。这不是为了偷窥，而是为了排查问题 — "张老师说她看到的数据不对，让我切过去看看"。

变身之后，所有操作都以那个老师的身份执行。用完了再"变回来"。

### 邮箱白名单

管理员可以设置"只有这些邮箱的人才能注册"。就像一个派对的邀请名单，名单上没有的人进不来。如果不设置白名单，就是"开放模式"，谁都能注册。

---

## 七、前端长什么样？

### 页面结构

打开系统，你看到的是一个**单页应用（SPA, Single Page Application）**。大白话：整个系统就一个网页，所有功能通过切换 Tab 来展示，不会像传统网站那样每点一个链接就加载一个新页面。就像一个 App 里有不同的标签页。

```
┌────────────────────────────────────────┐
│  课堂反馈 │ 作业管理 │ 批改 │ 打分 │ 记录  │  ⚙️ 设置
├────────────────────────────────────────┤
│                                        │
│         （当前 Tab 的内容）              │
│                                        │
└────────────────────────────────────────┘
```

- **课堂反馈 Tab**：填写课堂信息 → 点击生成 → 看进度 → 看结果
- **作业管理 Tab**：管理学生花名册 + 输入作业信息 + 查看学生状态
- **批改 Tab**：选学生 → 上传作业 → 看 AI 批改结果
- **打分 Tab**：选日期范围 → AI 打分 → 同步到学生档案
- **记录 Tab**：查看所有历史任务
- **设置**：配置 AI 模型、API 密钥、Google Drive 路径等

### 前后端怎么"对话"

前端和后端之间通过 **tRPC** 通信。tRPC 最大的特点是**类型安全** — 你可以理解为前端和后端之间有一份"合同"，合同上写清楚了"你问什么格式的问题，我给什么格式的答案"。如果哪一方违反了合同，代码编辑器会直接报错，不用等到上线才发现问题。

举个例子：
```
合同规定：查询学生列表 → 返回 [{名字, 计划类型, 状态}, ...]

前端："给我学生列表"（格式对的 ✅）
后端：返回 [{名字: "小明", 计划类型: "weekly", 状态: "active"}, ...]（格式对的 ✅）

如果后端不小心返回了 {名字: "小明", 年龄: 15}
→ 编译时就报错：你返回的格式不对！合同上没有"年龄"这个字段！
```

前端还用了 **React Query** 来管理数据请求。它会**自动缓存**数据 — 比如你刚查过学生列表，切到别的 Tab 再切回来，它不会重新问后端要数据，而是直接用上次的结果。省时省力。

---

## 八、系统怎么"盖起来"的（构建和部署）

### 构建 — 从源代码到可运行的程序

我们写的代码（TypeScript）浏览器和服务器都不能直接运行，需要先**编译/打包（Build）**。就像你写了一本书的手稿，要先送去印刷厂排版印刷，才能变成一本能卖的书。

```
npm run build 这条命令做了三件事：

1. 生成版本号信息（V180 是第几版）
2. 前端打包：把所有 React 代码变成浏览器能运行的 HTML + JS + CSS
   → 产物放在 dist/public/ 文件夹
3. 后端打包：把所有后端代码合成一个文件
   → 产物是 dist/index.js
```

### 部署 — 让系统跑起来

系统部署在 **Manus 平台**上，这是一个云端的沙箱环境（你可以理解为"一台远程的电脑"）。

```
Manus 沙箱里面有：
├── 我们的程序（dist/index.js）
│   它同时干两件事：
│   ├── 给你提供网页（前端静态文件）
│   └── 处理所有业务逻辑（后端 API）
├── MySQL 数据库
└── fonts/ 文件夹（中文字体，画气泡图用的）
```

这个沙箱有一些限制：
- 不能装某些软件（比如 rclone），所以 Google Drive 操作只能用 API
- 不能访问系统的字体文件夹，所以我们把中文字体放在了项目自己的 `fonts/` 文件夹里

### 环境变量 — 系统的"密码本"

**环境变量（Environment Variables）** 就是一些敏感的配置信息，不能写在代码里（否则上传到 GitHub 人人都能看到），而是单独配置在服务器上。

比如：
- 数据库的连接地址和密码
- Google 的客户端密钥
- 签名用的密钥

就像你不会把家门钥匙刻在门上，而是随身带着。

---

## 九、错误处理 — 出了问题怎么办

AI 调用可能会失败（网络不好、密钥过期、余额不足……），系统会把这些英文错误翻译成中文告诉你：

| 出了什么问题 | 系统告诉你 |
|-------------|-----------|
| API 密钥填错了 | "API密钥无效或已过期" |
| AI 服务不让你用 | "API访问被拒绝" |
| 问得太频繁了 | "请求过于频繁，请稍后重试" |
| AI 想了太久没回答 | "AI响应超时，请稍后重试" |
| 你的 AI 账户没钱了 | "API余额不足" |

后台任务失败了怎么办？系统会把错误记下来，你可以在"任务记录"里看到哪个任务失败了、失败原因是什么。

---

## 十、版本管理 — 每次改动都有编号

### 版本号

每次我们修改系统，都会给它一个新的版本号：V1, V2, V3……一直到现在的 V180。你在网页右下角能看到当前版本号。

版本号的作用就像书的"第X版" — 方便我们追踪"这个 bug 是哪个版本引入的""这个功能是哪个版本加的"。

### 数据库迁移

当我们需要给数据库加新的"表格"或新的"列"时，会写一个**迁移文件（Migration）**。就像你在 Excel 里加一列新数据一样，只不过我们需要写一段代码来做这件事。

关键规则：**迁移文件只能新增，不能删除**。这就像法律只能新增修正案，不能把旧的撕掉。因为删了旧的迁移文件，系统就不知道数据库是怎么一步步变成现在这样的了。

---

## 十一、几个重要的设计决定

### 为什么用后台任务，而不是让你干等着？

早期版本是"你点了生成，就在那等着 AI 写完"。问题是：
- AI 写完 5 份文档可能要 2-3 分钟
- 你的手机锁屏了 → 网络断了 → 之前的工作全白费

现在改成后台任务模式：你点了生成，系统把任务记下来，在后台慢慢做。你可以关掉网页，等会再来看结果。哪怕服务器重启了，任务也不会丢（因为已经存到数据库里了）。

### 为什么作业管理用"迭代更新"而不是"追加记录"？

如果每次都新加一条记录：
- 过了一个月，小明有 30 条记录
- 你要翻完 30 条才知道他现在啥情况
- 累不累？

迭代更新：永远只有**一份**最新的状态文档，新信息直接融进去。你打开就是最新全貌，不用翻历史。

### 为什么字体要放在项目目录里？

正常来说，字体文件在操作系统的字体文件夹里。但我们的部署环境（Manus 沙箱）不让程序访问那个文件夹。解决方案很简单粗暴：把字体文件直接放在我们自己的项目里，绕过限制。

---

## 十二、一图总结

```
                        ┌──────────────┐
                        │   老师的浏览器  │
                        │   （前端）      │
                        └──────┬───────┘
                               │
                    点按钮、填信息、看结果
                               │
                        ┌──────▼───────┐
                        │   服务器程序    │
                        │   （后端）      │
                        │              │
                        │  ┌─────────┐ │
                        │  │ tRPC 路由│ │ ← 接收前端的请求，分发给对应的处理模块
                        │  └────┬────┘ │
                        │       │      │
                        │  ┌────▼────┐ │
                        │  │ 业务模块 │ │ ← 反馈生成、作业管理、批改、打分……
                        │  └────┬────┘ │
                        │       │      │
                        │  ┌────▼────┐ │
                        │  │ AI 客户端│ │ ← 把请求发给 AI 大模型，拿回结果
                        │  └─────────┘ │
                        └──┬────────┬──┘
                           │        │
                    ┌──────▼──┐  ┌──▼──────────┐
                    │  MySQL   │  │ Google Drive │
                    │ 数据库    │  │ 网盘         │
                    │ 存数据    │  │ 存文件       │
                    └─────────┘  └─────────────┘
```

**用一句话说完整个系统：**

老师在网页上填课堂信息 → 后端收到请求 → 把信息喂给 AI → AI 生成文档 → 文档传到 Google Drive → 老师拿到链接，完事儿。

---

## 十三、想了解更多？

| 想看什么 | 去哪看 |
|---------|--------|
| 专业版技术文档（给技术人员看的） | `docs/技术说明书.md` |
| 功能清单和设计决策 | `docs/项目概述.md` |
| 每个版本都改了什么 | `docs/迭代记录.md` |
| 踩过的坑和经验教训 | `docs/技术备忘.md` |
| 出过什么 bug 怎么修的 | `docs/问题追踪.md` |
| 多租户隔离怎么做的 | `docs/租户隔离改造清单.md` |
| 部署需要配什么环境变量 | `docs/环境变量配置模板.md` |
