# 第七章 设计决策与已知问题

> **学情反馈系统 (feedback-mvp) 技术手册**
> 版本 V179 | 2026-02-16

---

## 7.1 技术选型决策

### 7.1.1 API 层：为什么选 tRPC 而不是 REST

| 对比项 | tRPC | REST |
|--------|------|------|
| 类型安全 | 端到端自动推导，前后端共享类型 | 需手写 OpenAPI spec 或 codegen |
| 输入校验 | Zod schema 声明式校验，自动绑定 | 手写中间件或 Joi/Yup |
| 前端集成 | @trpc/react-query 原生缓存和状态管理 | 手动封装 fetch + 状态管理 |
| 路由定义 | 单文件 `routers.ts` 定义全部过程 | 多文件分散定义路由 |

**选择 tRPC 的核心原因：** 本项目前后端都是 TypeScript，tRPC 让新增接口只需定义一次 Zod schema，前端调用自动获得类型提示，无需维护接口文档和类型定义的同步。

**代价：**
- `routers.ts` 随功能增长膨胀到 3400+ 行
- Zod schema 静默丢弃未声明字段（详见 7.5.1）

### 7.1.2 实时通信：为什么选 SSE 而不是 WebSocket

| 对比项 | SSE | WebSocket |
|--------|-----|-----------|
| 方向 | 服务端 → 客户端（单向） | 双向 |
| 协议 | 标准 HTTP | 独立协议，需 upgrade |
| 代理穿越 | 无障碍（就是普通 HTTP 响应） | 需代理特殊配置 |
| 浏览器支持 | 原生 EventSource API | 需要 ws 库 |
| 断开检测 | `req.on('close')` 即可 | 需心跳机制 |

**选择 SSE 的核心原因：** 学情反馈的实时需求是"服务端向客户端推送生成进度和结果"，是纯单向推送场景。SSE 比 WebSocket 简单得多，且与 `AbortController` 无缝集成——客户端断开时能立即中止 AI token 消耗，避免浪费 API 费用。

**实现细节：**

```typescript
// 客户端断开 → 自动中止 AI 调用
const clientAbort = new AbortController();
req.on('close', () => {
  console.log('[SSE] 客户端断开，中止AI流');
  clientAbort.abort();
});
```

### 7.1.3 后端构建：为什么选 esbuild 而不是 webpack

| 对比项 | esbuild | webpack |
|--------|---------|---------|
| 速度 | < 1 秒 | 几十秒 |
| 配置复杂度 | 一行命令 | 需 webpack.config.js |
| ESM 支持 | 原生 | 需额外配置 |
| Node.js 兼容 | `--platform=node --packages=external` | 需 node-externals 插件 |

**选择 esbuild 的核心原因：** 本项目是 ESM（`"type": "module"`），esbuild 原生支持。后端打包只需一条命令：

```bash
esbuild server/_core/index.ts --bundle --format=esm --platform=node --packages=external --outfile=dist/index.js
```

`--packages=external` 表示不打包 node_modules，运行时从目录加载。这样 bundle 只包含项目代码，体积小且构建快。

### 7.1.4 SVG 渲染：为什么选 @resvg/resvg-js 而不是 sharp

**这是一个被迫的选择，但结果更好。**

| 对比项 | @resvg/resvg-js | sharp |
|--------|-----------------|-------|
| ESM 兼容 | 原生支持 import | 需要 require()，ESM 中无法使用 |
| 底层实现 | Rust (Wasm) | C++ (libvips) |
| 字体控制 | 可指定字体文件和目录 | 依赖系统字体配置 |
| SVG 渲染质量 | 优秀 | 较好 |

**历史：** V129 之前使用 sharp，但 esbuild 将后端打包为 ESM 后，sharp 因为内部使用 `require()` 无法在 ESM 中加载。改用 resvg 后发现它对字体加载的控制更精细，可以显式指定字体文件路径，这恰好解决了 Manus 沙箱中的字体问题。

### 7.1.5 ORM：为什么选 Drizzle + 手写 SQL

| 对比项 | Drizzle | Prisma | 纯手写 SQL |
|--------|---------|--------|-----------|
| 类型安全 | 有（schema 推导类型） | 有（codegen） | 无 |
| 迁移工具 | drizzle-kit（需 DB 连接） | prisma migrate | 无 |
| 运行时依赖 | 轻量 | 较重 | 无 |
| 学习曲线 | 接近原生 SQL | 自有 DSL | 无 |

**选择 Drizzle 的核心原因：** 类型安全且接近原生 SQL 写法。

**但有一个重要限制：** 开发环境没有 `DATABASE_URL`（无法连接数据库），所以 `drizzle-kit generate`（生成迁移文件）无法运行。解决方案是 **手写 SQL 迁移文件**，所有建表语句使用 `CREATE TABLE IF NOT EXISTS`，新增列使用 `ALTER TABLE ADD COLUMN`，保证幂等性。

### 7.1.6 文件存储：为什么选 Google Drive OAuth API 而不是 rclone

| 对比项 | OAuth API | rclone |
|--------|-----------|--------|
| 安装要求 | 无（纯 HTTP 调用） | 需安装 rclone 二进制 |
| 多用户支持 | 每用户独立 token | 全局配置 |
| 精细控制 | 文件夹创建、权限、搜索 | 命令行参数 |
| 沙箱兼容 | 无限制 | Manus 沙箱未安装 |

**选择 OAuth API 的核心原因：** Manus 沙箱环境没有安装 rclone。使用 Google Drive REST API + OAuth token，每个用户独立授权，代码完全自主控制上传、搜索、文件夹创建等操作。

### 7.1.7 为什么用 mediumtext 存 JSON 而不是 MySQL JSON 类型

| 对比项 | mediumtext | MySQL JSON |
|--------|-----------|------------|
| 容量 | 16MB | 1GB |
| 兼容性 | 所有 MySQL 版本 | MySQL 5.7.8+ |
| 查询 | 应用层解析 | 支持 `JSON_EXTRACT` |
| 索引 | 不支持 JSON 路径索引 | 支持虚拟列索引 |

**选择 mediumtext 的原因：**
1. 本项目的 JSON 数据（如 `inputParams`、`stepResults`）只在应用层整体读写，不需要数据库层面的 JSON 路径查询
2. 16MB 足够存储最大的录音转文字文本 + 生成结果
3. mediumtext 在 Drizzle ORM 中的类型映射更简单直接

### 7.1.8 认证方式：为什么选 Cookie 而不是 JWT

| 对比项 | httpOnly Cookie | JWT Bearer |
|--------|----------------|------------|
| 安全性 | JavaScript 无法访问（防 XSS） | 存 localStorage 有 XSS 风险 |
| 自动发送 | 浏览器自动带上 | 需手动设置 header |
| 服务端状态 | 需要（数据库校验 openId） | 无状态 |
| Manus iframe | 需 SameSite=none + Secure | 无此问题 |

**选择 Cookie 的核心原因：** httpOnly Cookie 防止 XSS 攻击窃取令牌。代价是需要设置 `SameSite: "none"` 和 `Secure: true` 来适配 Manus iframe 嵌入场景。

---

## 7.2 核心设计模式

### 7.2.1 配置快照机制

**问题：** 后台任务可能运行数分钟，期间用户可能修改配置（API 密钥、模型、路书等），导致任务前半段用旧配置、后半段用新配置，产生不一致。

**解决方案：** 前端提交任务时一次性读取全部配置，作为 `inputParams` JSON 存入数据库。任务执行全程只用快照值，不再查询当前配置。

```
前端：读取当前配置 → 全部放入请求参数
     ↓
后端：存入 inputParams（JSON）
     ↓
执行器：只从 inputParams 读配置，不查 DB
     ↓
用户中途改配置 → 不影响正在运行的任务
```

**涉及的配置项：** `apiModel`、`apiKey`、`apiUrl`、`roadmap`、`driveBasePath`、`maxTokens` 等。

### 7.2.2 配置优先级

系统存在三层配置，优先级从高到低：

```
user_config（用户级，每用户独立）
    ↓ 找不到时
DEFAULT_CONFIG（代码常量，server/core/aiClient.ts）
```

**关键设计：有 userId 时不 fallback 到 system_config。**

```typescript
// 有 userId 时：仅查 user_config，不穿透到 systemConfig（防止跨租户泄露）
if (userId != null) {
  const userResult = await db.select().from(userConfig)
    .where(and(eq(userConfig.userId, userId), eq(userConfig.key, key)));
  if (userResult.length > 0) return userResult[0].value;
  return DEFAULT_CONFIG[key] || "";  // 直接返回代码默认值
}
```

**原因：** `system_config` 表存储的是系统级配置（如邮箱白名单），不应该被用户级查询读到。用户之间的配置严格隔离。

### 7.2.3 AI 输出自动续写

**问题：** AI 模型有单次输出 token 上限（通常 64K token），长学情反馈可能被截断。

**解决方案：`invokeWithContinuation()` — 哨兵检测 + 多轮对话续写**

```
第 1 轮：发送 system + user prompt → AI 生成内容
  ├── 检测截断标记 '【⚠️ 内容截断警告】'
  ├── 未检测到 → 完成，返回
  └── 检测到 → 进入续写
第 2 轮：发送 system + user + assistant(已有内容) + user("请从截断处继续")
  ├── 未检测到 → 完成，拼接返回
  └── 检测到 → 进入第 3 轮
...
最多 4 轮（MAX_CONTINUATIONS = 3），约可产出 24000+ 字符
```

**截断标记的来源：** 在系统提示词中要求 AI 在输出即将被截断时输出特定标记 `【⚠️ 内容截断警告】`。`invokeWhatAIStream` 在检测到 `finish_reason=length`（token 耗尽）时也会自动追加此标记。

**续写指令（防止重复）：**
> "你的回答被截断了，请从截断处继续输出。直接继续输出剩余内容，不要重复已有内容，不要添加过渡语句。"

### 7.2.4 并发控制

系统在多个层面实施并发限制：

**后台任务（backgroundTaskRunner.ts）：**

```typescript
const MAX_CONCURRENT_TASKS = 3;
let _runningTaskCount = 0;

// 超限立即拒绝，不排队
if (_runningTaskCount >= MAX_CONCURRENT_TASKS) {
  // 标记为 failed，返回"服务器繁忙"
  return;
}
_runningTaskCount++;
runTask(taskId).finally(() => { _runningTaskCount--; });
```

- **硬限 3 个并发** — 防止 AI API 被打爆限速
- **超限立即拒绝** — 前端提示"服务器繁忙，请稍后重试"
- **不排队** — 简化逻辑，避免队列积压

**批量任务子项重试去重（batchTaskRunner.ts）：**

```typescript
const _retryLocks = new Set<string>();

async function retryBatchItem(batchId: string, taskNumber: number) {
  const lockKey = `${batchId}:${taskNumber}`;
  if (_retryLocks.has(lockKey)) {
    throw new Error("该任务正在重试中，请稍候");
  }
  _retryLocks.add(lockKey);
  try {
    await _doRetryBatchItem(batchId, taskNumber);
  } finally {
    _retryLocks.delete(lockKey);
  }
}
```

- 同一子任务的并发重试请求会被去重，只执行一次

**Google Drive 文件夹创建去重（gdrive.ts）：**

```typescript
const pendingFolderOps = new Map<string, Promise<string>>();

// 同一路径的并发请求共享同一个 Promise
// 避免在批量上传时创建多个同名文件夹
```

### 7.2.5 任务取消机制

后台任务支持用户主动取消：

```
用户点击取消
  → cancelBackgroundTask(taskId)
    → 获取对应的 AbortController
    → controller.abort()
      → AI API 调用收到 AbortSignal → 中止 token 消耗
      → 任务循环中的 checkCancellation() 检测到取消
        → 更新 DB 状态为 "cancelled"
        → 保存已完成的步骤结果（partial）
```

关键点：取消不是立即中止，而是在下一个检查点优雅退出，已完成的步骤结果会被保留。

---

## 7.3 错误处理体系

### 7.3.1 结构化错误

**文件：** `server/errorHandler.ts`

所有 AI API 错误被转换为结构化的中文提示：

```typescript
interface StructuredError {
  code: string;           // 'insufficient_user_quota' | '429' | 'timeout' | ...
  step: string;           // '学情反馈' | '复习文档' | '气泡图' | ...
  message: string;        // "API余额不足"
  suggestion: string;     // "请登录DMXapi官网充值后重试"
  originalError?: string; // 原始错误信息（调试用）
}
```

**错误码覆盖：**

| 类别 | 错误码 | 中文消息 | 可重试 |
|------|--------|---------|--------|
| 余额 | `insufficient_user_quota` | API余额不足 | 否 |
| 认证 | `401` / `unauthorized` | API密钥无效 | 否 |
| 限速 | `429` / `rate_limit` | 请求太频繁 | 是 |
| 超时 | `timeout` / `aborterror` | 请求超时 | 是 |
| 网络 | `fetch failed` / `econnrefused` | 网络连接失败 | 是 |
| 服务器 | `500` / `502` / `503` / `504` | API服务器错误 | 是 |
| 模型 | `model_not_found` | 模型不存在 | 否 |

### 7.3.2 重试策略

**AI API 调用（whatai.ts）：**

```
调用失败
  ├── 401/403 → 不可重试，直接抛出
  └── 其他错误 → 递增延迟重试
      ├── 第 1 次重试：等 2 秒
      ├── 第 2 次重试：等 4 秒
      └── 全部失败 → 抛出最后一个错误
默认最多重试 2 次（共 3 次尝试）
```

**Google Drive 上传（gdrive.ts）：**
- 超时保护：普通请求 60 秒，上传请求 120 秒
- 文件夹创建共享 Promise 避免重复创建

### 7.3.3 为什么使用流式 API 做后台任务

**文件注释原文（feedbackGenerator.ts:818-823）：**

> 使用流式API（stream:true）保持连接活跃，防止长时间生成时中间网络层（Cloudflare/CDN/NAT）因连接空闲而断开。非流式调用在等待6-7分钟的大输出时，TCP连接无数据流动，极易被中间层判定为空闲连接并终止（导致 "fetch failed"）。

即使后台任务不需要实时推送给前端，仍然使用流式 API——不是为了 SSE，而是为了保持 TCP 连接活跃。

---

## 7.4 多租户数据隔离

### 7.4.1 隔离方式

所有业务表都包含 `user_id` 列，所有查询都附加 `WHERE user_id = ?`：

```typescript
// 典型查询模式
const tasks = await db.select().from(backgroundTasks)
  .where(eq(backgroundTasks.userId, ctx.userId))
  .orderBy(desc(backgroundTasks.createdAt));
```

### 7.4.2 管理员访问

管理员可以通过"伪装登录"功能查看其他用户的数据，但 **不绕过隔离机制** ——而是临时将 session 的 userId 切换为目标用户的 userId，所有查询仍然走 `WHERE user_id = ?`。

### 7.4.3 配置导出安全

配置备份导出（`config.export`）只导出当前用户的 `user_config`，不包含其他用户的数据。API Key 在导出时被遮蔽为 `****`。

---

## 7.5 已知限制与历史问题

### 7.5.1 Zod Schema 静默丢弃字段

**严重程度：高（已多次导致生产 Bug）**

tRPC 的 Zod schema 对未声明的字段**静默丢弃**，不会报错。

**典型事故（V137 之前）：**
- 前端新增了 `students` 字段传给后端
- 但后端 Zod schema 没有声明 `students`
- 请求被 Zod 校验时 `students` 被静默移除
- 后端收到 `students: undefined`，功能失败
- 没有任何错误日志，极难排查

**防御措施：** 新增前后端数据字段时，**必须同步检查** tRPC 路由中对应的 Zod schema。

### 7.5.2 Manus 沙箱字体不可见

**严重程度：中（已修复，但需了解背景）**

| 版本 | 问题 | 修复 |
|------|------|------|
| V129 | sharp 在 ESM 中无法使用 | 换为 @resvg/resvg-js |
| V130 | resvg `loadSystemFonts` 找不到字体 | 添加 9 个常见路径 + 目录扫描 |
| V131 | 系统字体目录可能不可访问 | 字体文件复制到项目 `fonts/` 目录 |
| V134 | Noto CJK 在 opentype 目录被遗漏 | 显式覆盖 `/usr/share/fonts/opentype/noto` |

**当前方案：**
- 字体查找优先级：项目 `fonts/` 目录 > 系统 opentype 目录 > 系统 truetype 目录
- 首次调用时运行完整的字体环境诊断，输出到控制台日志
- 诊断结果缓存，后续调用不再重复扫描

### 7.5.3 Drizzle 元数据不同步

**严重程度：低（不影响运行）**

`drizzle/_journal.json` 记录的迁移版本与实际 SQL 文件不完全一致（V1-V007 期间）。

**原因：** 早期开发时手动调整过迁移文件，没有同步更新 journal。

**影响：** `drizzle-kit` 的版本追踪功能不准确。但由于本项目不依赖 drizzle-kit 执行迁移（使用运行时 `CREATE TABLE IF NOT EXISTS`），所以不影响实际运行。

### 7.5.4 本地无 DATABASE_URL

**严重程度：低（影响开发流程）**

开发环境没有数据库连接，无法运行：
- `drizzle-kit generate` — 不能自动生成迁移文件
- `drizzle-kit migrate` — 不能测试迁移

**应对：** 手写 SQL 迁移文件，所有语句保证幂等性。表结构修改在生产环境首次启动时自动执行。

### 7.5.5 部署顺序错误导致 checkpoint 失败

**严重程度：高（已通过流程规范解决）**

```
❌ 错误：merge → build → push GitHub → checkpoint
   原因：checkpoint 把 git remote 切到 S3，先 push 后 remote 已指向 GitHub，
         checkpoint 时本地历史和 S3 历史分叉 → 失败

✅ 正确：merge → build → checkpoint → push GitHub
```

此问题已记录在 COLLAB.md 和第六章部署流程中，并作为团队操作规范强制执行。

---

## 7.6 性能相关决策

### 7.6.1 为什么超时设置为 15 分钟

AI 生成学情反馈是长时间操作（5 个步骤串行/并行，每步可能需要 1-3 分钟 AI 调用 + 自动续写 + Google Drive 上传）。15 分钟的 Express server timeout 确保整个流程不会被 HTTP 层面提前中断。

所有超时配置保持一致：Express server timeout = keepAliveTimeout = tRPC 路由超时 = 15 分钟。`headersTimeout` 设为 15 分钟 + 1 秒，略大于 keepAlive。

### 7.6.2 为什么后台任务限制 3 个并发

AI API（DMXapi 中转）有请求频率限制。3 个并发任务 × 每任务可能 4 轮续写 = 同时最多 12 个 AI 调用，在不触发限速的安全范围内。

超限时立即拒绝而非排队，因为：
1. 用户能立即知道当前服务器繁忙
2. 避免队列积压导致任务等待时间不可预期
3. 简化实现，减少 Bug 风险

### 7.6.3 录音转文字压缩

大量录音转文字内容可能极长（数万字），直接发给 AI 会消耗大量 token 且可能超出上下文窗口。

```typescript
const TRANSCRIPT_COMPRESS_CONFIG = {
  maxLength: 4000,   // 超过 4000 字才压缩
  chunkSize: 3000,   // 每段 3000 字
  targetRatio: 0.5,  // 压缩到 50%
};
```

先用 AI 分段压缩，再将压缩后的文本用于反馈生成，平衡信息完整性和 token 消耗。

---

## 7.7 代码组织模式

### 7.7.1 项目结构

```
feedback-mvp/
├── client/src/          # React 前端（Vite 构建）
│   ├── pages/           # 页面组件（Home, Settings, HomeworkManagement, ...）
│   ├── components/      # 共享组件
│   └── lib/             # 工具函数、tRPC client
├── server/              # Express + tRPC 后端（esbuild 构建）
│   ├── _core/           # 核心基础（启动、Auth、OAuth SDK）
│   ├── core/            # AI 客户端、配置、文件处理
│   ├── batch/           # 批量任务子系统
│   ├── routers.ts       # tRPC 路由定义（3400+ 行）
│   ├── feedbackGenerator.ts  # 反馈生成（1500+ 行）
│   └── homeworkManager.ts    # 学生管理（950+ 行）
├── shared/              # 前后端共享类型和常量
├── drizzle/             # 数据库 schema 和迁移 SQL
├── fonts/               # 中文字体文件（供 resvg 渲染）
├── docs/                # 技术文档
└── scripts/             # 构建脚本（版本号生成等）
```

**为什么不用 monorepo workspace：** 本项目规模适中，单 `package.json` 管理所有依赖更简单。前后端通过 `shared/` 目录共享类型定义，构建时由 Vite（前端）和 esbuild（后端）分别处理。

### 7.7.2 大文件的内部组织

| 文件 | 行数 | 组织方式 |
|------|------|---------|
| `routers.ts` | 3400+ | 按命名空间分组：auth、config、feedback、bgTask、batchTask、homework、correction、grading、reminder |
| `feedbackGenerator.ts` | 1500+ | 按功能分区：生成函数 → 提示词预览 → 字体处理 → SVG 渲染 → 截断续写 |
| `classStreamRoutes.ts` | 1400+ | 按 SSE 端点分组，每个端点独立完整 |
| `homeworkManager.ts` | 950+ | 按操作分组：CRUD → AI 处理 → 批量操作 → 状态跟踪 |

### 7.7.3 版本号管理

**单一来源：** `scripts/generate-version.cjs` 第 10 行

```javascript
const VERSION = 'V179';
```

**构建时** 自动生成 `client/src/version.generated.ts`：

```typescript
export const VERSION = "V179";
export const COMMIT_HASH = "abc1234";
export const VERSION_DISPLAY = "V179 (abc1234)";
```

前端通过导入 `version.generated.ts` 显示当前版本。此文件是构建产物，不应手动编辑。

### 7.7.4 文件命名约定

**Google Drive 文件搜索与上传：**

| 场景 | 格式 | 示例 |
|------|------|------|
| 搜索云盘候选 | `{姓名}{课次}.md` | `孙浩然第12次.md` |
| 上传文件 | `{姓名}{课次}学情反馈.md` | `孙浩然第12次学情反馈.md` |

搜索时不加"学情反馈"后缀（因用户手动上传的文件通常不带），上传时加上以便区分。

---

## 7.8 安全设计考量

### 7.8.1 API Key 永不返回前端

```typescript
// config.getAll 返回时遮蔽 API Key
apiKey: "",
hasApiKey: Boolean(apiKeyValue),
```

前端只知道"有没有配置 API Key"，不知道具体值。配置导出功能同样遮蔽 API Key。

### 7.8.2 输入校验层次

```
前端 Zod schema（react-hook-form）
  ↓ 初步校验
tRPC Zod schema（服务端）
  ↓ 严格校验（信任边界）
业务逻辑层
  ↓ 运行时检查
数据库约束（NOT NULL、UNIQUE、外键索引）
```

### 7.8.3 CORS 与 iframe 嵌入

系统需要在 Manus 平台的 iframe 中运行，因此：
- Cookie `SameSite: "none"` — 允许跨站 iframe 发送 Cookie
- Cookie `Secure: true` — HTTPS 环境下必须（SameSite=none 要求）
- Secure 检测支持代理链：检查 `req.protocol` 和 `x-forwarded-proto` header

---

## 7.9 数据库迁移策略

### 7.9.1 为什么不用标准迁移工具

标准迁移工具（drizzle-kit、Prisma Migrate、Flyway）需要在开发时连接数据库生成迁移文件。本项目的开发环境（Claude/Manus 沙箱）没有持久化数据库连接，因此采用**运行时幂等迁移**。

### 7.9.2 迁移原则

1. **只增不删** — `drizzle/` 目录下的迁移文件只允许新增，不允许删除或修改已有文件
2. **幂等性** — 所有 SQL 使用 `IF NOT EXISTS` 或捕获 `Duplicate column` 错误
3. **启动时执行** — 服务每次启动自动运行全部迁移，已存在的表/列会被安全跳过
4. **无回滚** — 不支持回滚操作（在此项目规模下尚未需要）

### 7.9.3 迁移文件示例

```sql
-- 0013_add_reminder_tasks.sql（典型的新增表迁移）
CREATE TABLE IF NOT EXISTS `reminder_tasks` (
  `id` int AUTO_INCREMENT PRIMARY KEY,
  `user_id` int NOT NULL,
  `reminder_prompt` mediumtext NOT NULL,
  ...
  INDEX `idx_reminder_userId` (`user_id`)
);
```

---

## 7.10 关键设计决策总结

| 决策 | 选择 | 核心理由 | 主要代价 |
|------|------|---------|---------|
| API 框架 | tRPC | 端到端类型安全 | Zod 静默丢弃字段 |
| 实时通信 | SSE | 简单 + AbortController | 单向推送 |
| 后端构建 | esbuild ESM | 秒级构建 | 不兼容 require() |
| SVG 渲染 | @resvg/resvg-js | ESM 原生 + 字体控制 | 项目需内置字体 |
| ORM | Drizzle + 手写 SQL | 类型安全 + 幂等迁移 | 无法用 drizzle-kit |
| 文件存储 | Google Drive OAuth | 沙箱可用 + 多用户 | 实现复杂度高 |
| JSON 存储 | mediumtext | 兼容性好 | 无 JSON 路径查询 |
| 认证 | httpOnly Cookie | 防 XSS | 需 SameSite=none |
| 并发控制 | 硬限 3 + 立即拒绝 | 防 API 限速 | 超限时用户需等待 |
| AI 续写 | 哨兵 + 多轮对话 | 自动恢复截断 | 最多增加 3 轮调用 |
