# 第五章 核心业务流程

> **学情反馈系统 (feedback-mvp) 技术手册**
> 版本 V179 | 2026-02-16

---

## 5.1 学情反馈生成流水线

这是系统最核心的业务流程，将课堂输入材料转化为 5 份标准化产出文档。

### 5.1.1 总体流程

```
用户输入                              AI 生成                           文件上传
┌─────────┐                    ┌──────────────┐                 ┌──────────────┐
│ 学生姓名  │                    │ 步骤1:学情反馈 │─ 串行 ──────────▶│ .md → Drive  │
│ 上次反馈  │                    │  (阻塞步骤)   │                 └──────────────┘
│ 课堂笔记  │──▶ 参数组装 ──▶    └──────┬───────┘
│ 录音转文字 │                          │ 反馈内容
│ 路书     │                    ┌──────▼───────┐                 ┌──────────────┐
└─────────┘                    │ 步骤2:复习文档 │─ 并行 ──────────▶│ .docx → Drive│
                               │ 步骤3:测试本   │─ 并行 ──────────▶│ .docx → Drive│
                               │ 步骤4:信息提取 │─ 并行 ──────────▶│ .md → Drive  │
                               │ 步骤5:气泡图   │─ 并行 ──────────▶│ .png → Drive │
                               └──────────────┘                 └──────────────┘
```

**关键设计：步骤 1 串行，步骤 2~5 并行。** 步骤 1 的输出（反馈内容）是步骤 2~5 的输入，因此必须先完成步骤 1。步骤 2~5 之间互相独立，可以并行执行以节省时间。

### 5.1.2 步骤 1：学情反馈生成

**文件：** `server/feedbackGenerator.ts` → `generateFeedbackContent()`

**输入组装（发给 AI 的 prompt）：**

```
## 学生信息
- 学生姓名：张三
- 课次：第12次
- 本次课日期：1月15日（周三）
- 下次课日期：请从课堂笔记中提取

## 上次反馈
{上次课反馈全文}

## 本次课笔记
{课堂笔记全文}

## 录音转文字
{录音转文字全文}

请严格按照V9路书规范生成完整的学情反馈文档。
```

**系统提示词（system prompt）：** 路书内容 + 格式要求（不用 Markdown 标记、不用表格、纯文本格式，因为反馈要直接复制到微信群）

**AI 调用方式：非流式 + 自动续写**

```
第 1 轮调用 → 获得内容（可能被截断）
  ↓ 检查是否以【OK】结尾
  ↓ 如果没有，说明被截断
第 2 轮调用 → "请从上次中断处继续" + 已有内容的最后 500 字
  ↓ 拼接
第 3 轮调用 → 同上（最多续写 3 次，共 4 轮）
  ↓ 拼接
最终内容 → 清理 AI 前言/结尾废话 → 返回
```

**自动续写机制（`invokeWithContinuation`）：**

- 最多续写 3 次（共 4 轮调用），约可产出 24000+ 字符
- 每轮将已有内容的最后 500 字符作为上下文传递
- 检测截断标志：内容是否以 `【OK】` 结尾
- 最后一轮如果仍被截断，标记为 `truncated` 但仍返回已有内容

**后处理：**

1. `stripAIMetaCommentary()` — 移除 AI 的开头前言（如"好的，以下是..."）和结尾废话（如"生成完成！"）
2. `cleanMarkdownAndHtml()` — 移除 Markdown 和 HTML 标记，保留下划线（填空题用）

**上传：** 反馈内容以 Markdown 文件上传到 Google Drive，路径为 `{driveBasePath}/{学生姓名}/{学生姓名}{课次}学情反馈.md`

### 5.1.3 步骤 2：复习文档生成

**文件：** `feedbackGenerator.ts` → `generateReviewContent()`

**输入：** 步骤 1 的反馈内容 + 路书

**AI 调用方式：** 流式（`invokeWithContinuation`），支持实时字符数回传

**后处理：**
1. `cleanMarkdownAndHtml()` → 纯文本
2. `textToDocx()` → 转换为 Word 文档
   - 识别 `【xxx】` 格式的章节标题
   - 识别 一、二、三 等小节标题
   - 识别 `===== 答案部分 =====` 等分隔符，插入分页符

**上传：** DOCX 二进制文件上传到 Google Drive

### 5.1.4 步骤 3：测试本生成

与复习文档流程完全一致，仅系统提示词不同（侧重测试题和答案）。

### 5.1.5 步骤 4：课后信息提取

**AI 调用方式：** 流式

**输出：** 结构化的课程关键信息（纯文本/Markdown）

**后处理：** `stripAIMetaCommentary()` + `cleanMarkdownAndHtml()`

**上传：** Markdown 文件上传到 Google Drive

**特殊用途：** 提取结果可一键导入到学生管理系统（`importFromExtraction`）

### 5.1.6 步骤 5：气泡图生成

**流程完全不同于前 4 步：**

```
AI 生成 JSON 数据 → 前端 Recharts 渲染 SVG → 服务端 resvg 转 PNG → 上传 Drive
```

1. AI 根据反馈内容生成气泡图数据（各维度评分 JSON）
2. 前端使用 Recharts 库渲染 SVG
3. SVG 字符串发送到服务端
4. 服务端使用 `@resvg/resvg-js` 将 SVG 渲染为 PNG
   - 字体从项目 `fonts/` 目录加载（优先 Noto Sans CJK，兜底 WenQuanYi Zen Hei）
5. PNG 上传到 Google Drive

> **为什么不在服务端直接生成 SVG？** 因为气泡图的布局和样式依赖 Recharts（React 组件库），服务端没有浏览器 DOM 环境无法渲染。

---

## 5.2 后台任务系统

**文件：** `server/backgroundTaskRunner.ts`

### 5.2.1 任务提交与调度

```
前端提交 → 写入 DB (status=pending) → 返回 taskId → 后台异步执行
                                        ↓
                              startBackgroundTask(taskId)
                                        ↓
                              检查并发数 ≤ 3 ?
                              ├── 是 → 开始执行
                              └── 否 → 立即标记 failed("服务器繁忙")
```

**并发控制：** 最多同时运行 3 个后台任务（`MAX_CONCURRENT_TASKS = 3`）。超过时立即拒绝，不排队等待。

### 5.2.2 任务执行流程

```
runTask(taskId)
  ├── 读取 DB 中的 inputParams
  ├── 判断 courseType
  │   ├── 'one-to-one' → runOneToOneTask()
  │   └── 'class'      → runClassTask()
  │
  └── runOneToOneTask(taskId, params, userId)
        ├── 步骤 1: generateFeedbackContent() + 上传     ← 串行
        │     ↓ 失败则整体 failed
        ├── 步骤 2-5: Promise.allSettled([              ← 并行
        │     generateReviewContent() + 上传,
        │     generateTestContent() + 上传,
        │     generateExtractionContent() + 上传,
        │     generateBubbleChartSVG() + svgToPng() + 上传
        │   ])
        └── 汇总结果 → 更新 DB
              ├── 全部成功 → completed
              ├── 部分失败 → partial
              └── 步骤 1 失败 → failed
```

**实时进度更新：** 每个步骤开始/完成/失败时，实时更新 DB 中的 `step_results` 和 `current_step`。前端通过轮询 `backgroundTasks.status` 接口获取最新状态。

### 5.2.3 任务取消

- 前端调用 `backgroundTasks.cancel`
- 后端通过 `AbortController` 发出取消信号
- AI 调用和文件上传检查 `signal.aborted`，及时终止
- 任务标记为 `cancelled`

### 5.2.4 自动恢复与清理

**服务启动时自动执行：**

1. `recoverInterruptedTasks()` — 将 running/pending 状态的任务标记为 failed（服务器重启意味着这些任务被中断）
2. `cleanupOldTasks()` — 删除 3 天以上的旧任务记录；将运行超过 30 分钟的任务标记为 failed（防卡死）

---

## 5.3 批量任务系统

**文件：** `server/batchTaskRunner.ts` + `server/batchExecutor.ts`

### 5.3.1 执行流程

```
提交批量任务（N 个子项，并发数 C）
  ↓
创建 batch_tasks 记录 + N 条 batch_task_items 记录
  ↓
启动执行循环（最多同时 C 个）
  ↓
┌─────────────────────────────┐
│  子任务 1  │  子任务 2  │ ... │  ← 并发执行，限制为 C 个
└─────┬───────────┬───────────┘
      │           │
      ▼           ▼
   AI 生成      AI 生成
      │           │
      ▼           ▼
  转换 DOCX    转换 DOCX
      │           │
      ▼           ▼
  上传 Drive   上传 Drive
      │           │
      ▼           ▼
  更新 DB      更新 DB
```

**并发控制：** 使用信号量（Semaphore）模式，确保同时运行的子任务数不超过用户设定的并发数（默认 50，上限 200）。

### 5.3.2 子任务执行

每个子任务的执行流程：

1. 读取路书内容 + 任务编号对应的独立文件 + 共享文件
2. 组装 AI prompt
3. 调用 AI 生成内容（流式，实时更新 `chars` 字段）
4. 根据模板类型转换格式（DOCX / Markdown）
5. 上传到 Google Drive
6. 更新 batch_task_items 记录

**错误处理：** 子任务之间互相独立，某个失败不影响其他。失败的子任务可以单独重试。

---

## 5.4 作业管理流程

**文件：** `server/homeworkManager.ts`

### 5.4.1 语音输入到学生状态的完整链路

```
语音转文字原文
      ↓
  submitAndProcessEntry()
      ↓
  创建 hw_entries 记录 (status=pending)
      ↓ 后台异步
  processEntryInBackground()
      ↓
  状态更新: pending → processing
      ↓
  processEntry()  ← AI 处理核心
      ↓
  ┌─ 有学生历史状态？
  │   ├── 是 → 迭代模式（在现有状态基础上更新）
  │   └── 否 → 全新模式（从零结构化）
  │
  │  系统提示词组装：
  │  ├── 北京时间上下文（年月日+时分+星期）
  │  ├── "以下学生姓名以系统提供的为准"
  │  └── 自定义提示词 / 默认提示词
  │
  │  用户消息组装：
  │  ├── 迭代模式：【当前状态文档】+ 【本次新增信息】
  │  └── 全新模式：【语音转文字原文】
  ↓
  AI 流式处理 → 每秒更新 streaming_chars
      ↓
  状态更新: processing → pre_staged
  parsed_content = AI 输出
      ↓
  用户在前端查看/确认
      ↓
  confirmEntries()
      ↓
  将 parsed_content 写入 hw_students.current_status
      ↓
  删除 hw_entries 中的预入库记录
      ↓
  自动备份到 Google Drive (fire-and-forget)
```

### 5.4.2 迭代更新机制

这是学生管理最核心的设计理念：

- 每个学生有一个 `current_status` 文档，记录该学生的所有累积状态
- 新的输入不是替换而是**在现有状态基础上迭代更新**
- AI 看到旧状态 + 新输入，智能决定哪些信息要更新、哪些保留、哪些删除
- 随着时间推移，`current_status` 成为该学生的完整画像

### 5.4.3 课后信息导入

从课堂反馈流水线（步骤 4：课后信息提取）向学生管理导入：

```
任务记录 / 主页
      ↓ 点击"导入作业管理"
importFromTaskExtraction(taskId, studentName)
      ↓
  读取后台任务的 step_results.extraction 内容
      ↓
  importFromExtraction(studentName, content)
      ↓
  自动创建学生（如不存在）/ 重新激活（如已删除）
      ↓
  创建 hw_entries (status=pending, rawInput="[从课后信息提取导入]\n{content}")
      ↓
  后台 AI 处理 → pre_staged → 等待用户确认
```

**小班课导入（N+1 模式）：** 小班课的导入会为每个出勤学生创建一条独立的条目，每条都经过独立的 AI 处理。

---

## 5.5 作业批改流程

**文件：** `server/correctionRunner.ts`

### 5.5.1 完整执行链路

```
前端提交
  ├── 文字内容（rawText）
  ├── 图片（base64 数组，前端已压缩）
  └── 文件（base64 编码的 docx/pdf/txt）
      ↓
submitCorrection(userId, params)
      ↓
  文件文本提取：
  ├── .docx → mammoth 提取纯文本
  ├── .pdf  → pdf-parse 提取纯文本
  └── .txt  → UTF-8 解码
      ↓
  图片上传到存储（如超 2MB）
      ↓
  读取学生当前状态 (hw_students.current_status)
      ↓
  创建 correction_tasks 记录 (status=pending)
      ↓ 后台异步
processCorrectionInBackground(userId, taskId)
      ↓
  组装系统提示词：
  ├── 北京时间上下文
  ├── 学生姓名声明
  ├── 通用批改提示词
  └── 类型专属提示词
      ↓
  组装用户消息：
  ├── 【学生当前状态】（如有）
  ├── 【学生提交的文字内容】
  ├── 【从文件提取的文字】
  └── 【图片】（多模态 AI 识别）
      ↓
  invokeAIStream() → 流式生成，每秒更新 streaming_chars
      ↓
  解析 AI 输出：
  ├── "=== 批改内容 ===" 之前 → result_correction
  └── "=== 状态更新 ===" 之后 → result_status_update
      ↓
  自动推送状态更新到学生管理：
  importFromExtraction(studentName, result_status_update)
      ↓
  更新 auto_imported = 1, import_entry_id = {新条目ID}
```

### 5.5.2 AI 输出拆分

AI 被要求按以下格式输出：

```
=== 批改内容 ===
{详细的批改结果，给学生看}

=== 状态更新 ===
{简要的状态信息，给学生管理系统用}
```

系统通过正则匹配分隔符拆分内容。如果 AI 没有按格式输出，则整体内容视为批改结果，状态更新为空。

---

## 5.6 一键打分流程

**文件：** `server/gradingRunner.ts`

### 5.6.1 打分生成

```
用户设定日期范围 + 打分要求
      ↓
  读取所有活跃学生的 current_status
      ↓
  组装系统提示词 + 用户消息（包含全部学生的状态快照）
      ↓
  AI 批量生成打分（一次 API 调用处理全部学生）
      ↓
  result 存入 grading_tasks
      ↓
  教师在前端查看/编辑打分结果
      ↓
  edited_result 存入 grading_tasks
```

### 5.6.2 打分同步到学生状态

```
点击"同步到学生状态"
      ↓
  为每个学生创建 grading_sync_items 记录
      ↓
  并发执行（默认 20 个同时）：
  ┌────────────────────────────────────┐
  │ 对于每个学生：                       │
  │   读取 current_status              │
  │   + 打分结果中该学生的部分            │
  │   → AI 生成更新后的状态文档           │
  │   → 写入 hw_students.current_status │
  └────────────────────────────────────┘
      ↓
  汇总：sync_completed / sync_failed
```

---

## 5.7 SSE 实时流式生成流程

**文件：** `server/classStreamRoutes.ts`

### 5.7.1 连接生命周期

```
前端 fetch(POST /api/feedback-stream)
      ↓
  服务端设置 SSE 响应头：
  Content-Type: text/event-stream
  Cache-Control: no-cache
  Connection: keep-alive
      ↓
  发送 event: start
      ↓
  AI 流式生成 → 每收到一块文本 → 发送 event: progress { chars }
      ↓
  生成完成 → 上传 Drive → 发送 event: complete { uploadResult }
      ↓
  关闭连接
```

### 5.7.2 客户端断开处理

```
客户端关闭页面 / 网络中断
      ↓
  Express 检测到连接断开
      ↓
  AbortController.abort()
      ↓
  AI API 调用被取消
      ↓
  清理资源，不再写入响应
```

### 5.7.3 内容兜底机制

SSE 连接可能因为网络原因中断，但 AI 已经生成了内容。为此系统提供兜底：

```
AI 生成完成 → 内容存入内存 contentStore（key = contentId）
           → 同时通过 SSE 推送给前端
                ↓
前端收到 complete 事件中的 contentId
                ↓
如果 SSE 中途断开，前端可通过 GET /api/feedback-content/:contentId 获取已生成的内容
                ↓
contentStore 中的内容短期留存后自动过期
```

---

## 5.8 Google Drive 文件操作

**文件：** `server/gdrive.ts`

### 5.8.1 上传流程

```
uploadToGoogleDrive(userId, content, fileName, folderPath)
      ↓
  获取用户的 OAuth Token
      ↓
  Token 过期？
  ├── 是 → 使用 refreshToken 刷新
  └── 否 → 直接使用
      ↓
  解析 folderPath（如 "Mac/Documents/学生档案/张三"）
      ↓
  逐级创建文件夹（如不存在）：
  Mac/ → Documents/ → 学生档案/ → 张三/
      ↓
  在目标文件夹中创建/更新文件
      ↓
  返回 { url, path, folderUrl }
```

### 5.8.2 文件搜索

```
searchFileInGoogleDrive(fileName, folderName, token)
      ↓
  Google Drive API: files.list
  查询: name = '{fileName}' AND '{folderId}' in parents
      ↓
  返回匹配的文件列表
```

**搜索命名规则：**
- 搜索时不带"学情反馈"后缀：`{学生姓名}{课次}.md`
- 上传时带后缀：`{学生姓名}{课次}学情反馈.md`

### 5.8.3 文件下载

前端通过代理端点 `GET /api/download-drive-file?fileId=xxx&fileName=xxx` 下载文件，服务端从 Drive API 获取文件二进制内容后转发给前端。这样避免了前端直接调用 Drive API 的 CORS 问题。

---

## 5.9 AI 客户端与配置

**文件：** `server/core/aiClient.ts`

### 5.9.1 配置优先级

```
获取某个配置值（如 apiModel）：
  ↓
1. 查询 user_config 表（userId + key）
   ├── 有值 → 返回
   └── 无值 ↓
2. 查询 system_config 表（key）
   ├── 有值 → 返回
   └── 无值 ↓
3. 使用代码内置默认值（DEFAULT_CONFIG）
   └── 返回
```

### 5.9.2 配置快照

为了**并发安全**，生成反馈时不实时读取配置，而是在任务创建时将配置快照存入 `inputParams`：

```
用户点击"生成"
  ↓
前端读取当前配置 → 作为参数传给后端
  ↓
后端收到参数 → 存入 DB (inputParams JSON)
  ↓
后台执行时从 inputParams 中读取配置
```

这意味着即使用户在任务执行期间修改了配置，正在运行的任务仍使用提交时的配置。

### 5.9.3 系统配置迁移

`migrateSystemConfigToAdmin()` 函数在 Owner 首次登录时执行，将旧的 system_config 中的配置复制到 Owner 的 user_config，实现从"全局配置"到"多用户各自配置"的迁移。仅对 Owner（OWNER_OPEN_ID 环境变量指定的用户）执行一次。
