# Manus 协作指南

基于 feedback-mvp 项目 V1-V152 的实战经验总结。

---

## 一、核心原则

Manus 的特点：

- 单次对话上下文有限（约100K-200K tokens）
- 任务越多，每个任务分到的"注意力"越少
- 不会主动问你"这里我不确定"，会直接按自己理解做
- 容易"既往不咎"——改完一个地方忘了改另一个关联的地方

**黄金法则：一次只让 Manus 做一件事，做完验收，再做下一件。**

---

## 二、任务量建议

### 单次任务的安全边界

| 任务类型 | 建议范围 | 超出会怎样 |
|------|------|------|
| 新建文件 | 1-2个文件，每个<300行 | 后面的文件质量下降，可能漏掉关键逻辑 |
| 修改现有代码 | 1个文件，3-5处修改 | 改了A忘了B，或者改完又改回去 |
| Bug修复 | 1个Bug | 修一个引入另一个，或者只修表面不修根因 |
| 功能迁移/重构 | 1个模块或1个端点 | 迁移不完整，新旧代码混用 |
| 多文件联动修改 | 最多3个文件 | 文件间接口对不上，漏改某个文件 |

### 实战案例

**反面教材（V45系列的教训）：**

- 错误做法："把4个SSE端点都加上日志记录"
  - 结果：只改了1个，其他3个忘了
- 错误做法："把max_tokens从16000改成32000，全部18处"
  - 结果：改了17处，漏了1处，那1处在某个边缘case触发截断
- 错误做法："实现SSE流式输出，包括前后端"
  - 结果：后端改了，前端事件解析逻辑有bug，调试了3轮才搞定

**正面示范：**

正确做法：

- 第1轮："先改 /api/feedback-stream 这一个端点，加上SSE响应头"
  - 验收：测试这个端点能返回SSE事件
- 第2轮："前端解析这个端点的SSE事件，先只处理complete事件"
  - 验收：前端能收到并显示内容
- 第3轮："加上progress事件的处理，显示实时字符数"
  - 验收：能看到进度
- 第4轮："这个端点OK了，用同样的模式改 /api/review-stream"
  - 验收：第二个端点也能用
- ...以此类推

---

## 三、常见偷工减料模式

### 1. "我帮你改了"但其实没改完

**表现：**
- 说"已更新所有X处"，实际只改了最明显的几处
- grep一下就能发现还有遗漏

**预防：**
- 要求 Manus 跑 `grep -r "旧代码" .` 确认没有遗漏
- 让 Manus 列出修改的每一处的文件名和行号

### 2. 复制粘贴综合症

**表现：**
- 4个类似的端点，代码99%相同，1%的差异藏着bug
- 因为是复制的，改一处要改4处，但 Manus 只改了1处

**预防：**
- 问 Manus "这段代码和哪些地方是重复的？"
- 如果重复超过3处，先让 Manus 抽取公共函数

### 3. 表面修复

**表现：**
- Bug：日期显示错误
- Manus 的修复：在显示的地方加了个+1
- 实际问题：日期解析逻辑就是错的，其他地方还会出问题

**预防：**
- 问"这个bug的根本原因是什么？"
- 问"还有其他地方用了同样的逻辑吗？"

### 4. 只改了能跑通的路径

**表现：**
- 正常流程测试通过
- 异常流程（超时、空值、超长内容）没处理

**预防：**
- 明确要求处理边界情况
- 给出测试用例："用24000字符的内容测一下"

### 5. 改完不验证

**表现：**
- 代码看起来对
- 但实际跑起来报错，因为有语法错误或者依赖没装

**预防：**
- 要求 Manus 跑一遍 `pnpm build` 或 `pnpm typecheck`
- 要求 Manus 给出测试命令和预期结果

---

## 四、任务下发模板

### 标准格式

```markdown
## 任务：[简短标题]

### 背景
[为什么要做这个，1-2句话]

### 目标
[做完之后是什么状态，可验证的]

### 具体要求
1. [第一步]
2. [第二步]
3. [第三步]

### 不要做
- [明确排除的事项]

### 验收标准
- [ ] [检查项1]
- [ ] [检查项2]

### 参考
- 文件位置：xxx
- 类似代码：xxx
```

### 实际例子

```markdown
## 任务：给一对一学情反馈SSE端点添加日志记录

### 背景
V45b改成SSE后，日志导出功能失效了，因为SSE端点里没调日志函数。

### 目标
点击"导出日志"能下载到本次生成的日志文件。

### 具体要求
1. 在 /api/feedback-stream 端点开头调用 createLogSession(studentName)
2. 在开始生成时调用 log.startStep('学情反馈')
3. 在生成完成时调用 log.endStep('学情反馈', true, { chars: content.length })
4. 在返回响应前调用 log.save()

### 不要做
- 不要改其他3个SSE端点（下一轮再改）
- 不要改日志模块本身的逻辑

### 验收标准
- [ ] 跑一次一对一生成
- [ ] 点击导出日志，能下载到文件
- [ ] 日志里有"学情反馈"步骤的耗时和字符数

### 参考
- SSE端点位置：server/classStreamRoutes.ts 第50-150行
- 日志模块用法：server/logger.ts 的 createLogSession 函数
```

---

## 五、验收检查清单

每次任务完成后，过一遍这个清单：

### 代码层面

- [ ] 跑了 `pnpm build`，无报错
- [ ] 跑了 `pnpm typecheck`，无类型错误
- [ ] 新代码有没有 `console.log` 调试语句要清理
- [ ] 硬编码的值（API密钥、路径）有没有暴露

### 逻辑层面

- [ ] 改动涉及的其他文件都改了吗？（grep确认）
- [ ] 边界情况处理了吗？（空值、超长、超时）
- [ ] 错误处理有吗？（try-catch、错误提示）

### 关联影响

- [ ] 这个改动会不会影响其他功能？
- [ ] 一对一和小班课都测了吗？
- [ ] 数据库有没有需要同步的改动？

### 文档

- [ ] 需要更新技术备忘吗？
- [ ] 需要更新迭代记录吗？

---

## 六、沟通话术

### 任务太大时

"这个任务我拆成3步来做：
1. 先做XXX，你验收
2. 再做YYY，你验收
3. 最后做ZZZ

我们先从第1步开始？"

### 发现 Manus 理解偏了

"等一下，我看你改的是A，但我要改的是B。
我再说清楚一点：[重新描述需求]
你先别改，告诉我你理解的是什么？"

### 怀疑 Manus 偷工减料

"改完了是吧，帮我跑一下：
`grep -rn '旧代码' server/`
确认一下没有遗漏的地方。"

### Manus 说"改好了"但你不放心

"OK，那我们来测一下：
1. 运行 `pnpm build`
2. 用这个测试数据跑一遍：[具体数据]
3. 截图给我看结果"

---

## 七、经验法则

### 任务拆分原则

1. **一个文件原则**：优先把任务限制在一个文件内
2. **30分钟原则**：如果描述任务需要超过5分钟，任务太大了
3. **三步原则**：如果任务超过3个步骤，拆成多轮

### 什么时候必须拆分

- 涉及前后端联调 → 先后端，验收，再前端
- 涉及数据库改动 → 先schema，验收，再代码
- 涉及多个相似模块 → 先做一个作为模板，验收，再复制到其他

### 什么任务可以合并

- 纯粹的批量替换（如 16000 → 32000）
- 纯粹的格式调整（如 清理console.log）
- 同一个函数内的多处修改

---

## 八、项目特定经验

### feedback-mvp 的坑点

| 坑 | 教训 |
|------|------|
| 4个SSE端点代码重复 | 改一个要改4个，必须一个一个来 |
| 前端SSE解析 | 事件类型判断、变量作用域，每个都是坑 |
| 日志系统 | 并发请求要用独立对象，不能用全局变量 |
| 超长内容 | 超过15000字符要分块，否则前端解析失败 |
| 日期处理 | 不要让AI自己算星期，直接告诉他 |

### 高风险操作

以下操作必须拆成多轮，每轮验收：

1. **回滚代码**：先备份，再回滚，验收后再继续
2. **数据库迁移**：先备份数据，再跑迁移，验收后再改代码
3. **API切换**：先在测试环境验证，再上生产
4. **认证流程**：OAuth这种涉及多端的，必须分步调试

---

## 九、大项目拆解方法

### 里程碑式拆解

对于较大的新功能（如V46批量处理），不要一次性下发任务书，而是：

1. 拆成里程碑：5个左右，每个里程碑2-4个步骤
2. 设关键里程碑：找到"最小可用版本"的节点
3. 保底策略：即使后面遇到困难，也有可用版本

**V46实际拆解示例：**

| 里程碑 | 步骤数 | 验收标志 |
|------|------|------|
| M1: 核心模块 | 3步 | 三个模块可独立导入 |
| M2: 页面框架 | 2步 | 大分页可切换 |
| M3: 单任务跑通 | 4步 | 1个任务能生成Word并上传 (关键) |
| M4: 并发池跑通 | 2步 | 5个并发任务正确显示 |
| M5: 完善收尾 | 3步 | 所有验收项通过 |

M3是关键里程碑：单任务跑通后，系统就有最小可用版本。即使M4并发池有问题，也可以先串行使用。

### "先跑通再优化"原则

遇到复杂功能时：

```
复杂方案          简单方案
  |                 |
并发池模式   vs   简单串行循环
  |                 |
实现难度高       先跑通，后续优化
```

具体做法：

- Step 3 并发池复杂 → 先用简单的串行循环替代，M4再优化
- Step 8 Word生成复杂 → 先输出纯文本，后续再加Word格式
- Step 10 并发整合困难 → 先降级为串行，保证功能可用

---

## 十、测试与排故

### 测试用例设计原则

1. **"1+1=2"级别**：用最简单的输入验证功能通路
2. **先老后新**：先测老功能没搞坏，再测新功能
3. **给具体数据**：不说"随便试试"，给出具体的测试输入

**好的测试用例示例（V46批量处理）：**

```
任务编号范围：1-3
并发数：2
测试路书：
---
你是一个测试助手。根据你的任务编号，完成对应任务：

- 任务1：写一首关于春天的四行小诗
- 任务2：写一首关于夏天的四行小诗
- 任务3：写一首关于秋天的四行小诗

输出要求：直接输出诗的内容，不要有任何开场白。
---

通过标准：
- [ ] 看到3个任务都执行了
- [ ] 字符数有实时更新
- [ ] Google Drive里出现了3个文件
```

### 排故流程

先排查上报，讨论清楚再修改：

```
发现问题
    |
下发排查任务书（不是修复任务书）
    |
Manus 排查并上报
    |
讨论确认问题根因和修复方案
    |
下发修复任务书
```

### 排查任务书模板

```markdown
## 任务：排查XX问题（先排查上报，暂不修改代码）

### 现象
[具体描述问题表现]

### 请排查
1. [排查点1]
2. [排查点2]
3. 打印关键节点的值：
   - [需要打印的变量1]
   - [需要打印的变量2]

### 请先排查上报
不要急着改代码，先把排查结果告诉我，包括：
1. 问题原因定位
2. 你认为应该怎么修
等讨论确认后再动手改。
```

### 让 Manus 加调试日志

定位问题时的有效手段：

"帮我在以下位置加调试日志：
1. [位置1]：打印 xxx 的值
2. [位置2]：打印 yyy 的值
3. [位置3]：打印 zzz 的值

跑一次测试，把日志贴给我看。"

---

## 十一、新功能集成经验

### 模板类型扩展（V47经验）

新增功能要考虑与现有功能并存：

**界面设计**：用下拉选择框区分模板类型

```
模板类型：[下拉选择]
  - 通用文档（Markdown转Word）← 原有功能
  - 词汇卡片（精确排版）    ← 新增功能
```

**后端处理**：根据模板类型走不同分支

```javascript
if (templateType === '通用文档') {
  // 原有逻辑：Markdown转Word
} else if (templateType === '词汇卡片') {
  // 新逻辑：JSON数据套用代码模板
}
```

### 技术确认先行

开始新功能前，先向 Manus 确认技术细节：

```
我需要确认V47批量处理功能的几个技术细节：

1. 「通用文档（Markdown转Word）」功能：
   - AI返回的内容是什么格式？
   - 后端转换逻辑在哪个文件？用的什么库？

2. 任务编号机制：
   - 路书里的任务编号占位符是怎么替换的？
   - 每个并发任务怎么区分？

请简要回复，不需要贴完整代码。
```

确认清楚再写任务书，避免任务书下发后发现技术路线不通。

---

## 十二、常见坑点补充

### JSON格式输出的坑

**问题**：让AI输出JSON时，AI可能会加上 ` ```json ` 标记

**错误输出**：
````
```json
{ "name": "test" }
```
````

**正确输出**：
```
{ "name": "test" }
```

**解决方法**：在路书里明确说明：

```
输出要求：
1. 只输出纯JSON数据
2. 不要输出任何Markdown代码块标记（不要```json和```）
3. 不要有任何开场白或结尾语
```

### 文件命名混乱

**问题**：新功能可能错误地复用了其他功能的命名逻辑

**V46案例**：批量处理生成的文件名显示为"任务01_学情反馈.docx"，混用了课堂反馈的命名

**预防**：
- 任务书里明确指定文件命名规则
- 新功能使用独立的命名函数，不要复用

### 功能漏实现

**问题**：说"参考一对一实现"，但漏掉了关键细节

**V44案例**：小班课"参考一对一"实现文件上传，但漏了：
- 保存 uploadResult
- 显示文件链接
- 年份参数传递

**预防**：
- 任务书列出具体要对齐的代码位置
- 明确写出"和一对一保持一致的点"

---

## 十三、版本管理

### 每次稳定版本打tag

```bash
# 打标签
git tag -a v45m -m "稳定版本：一对一+小班课功能完整"
git push origin v45m

# 回滚到标签
git checkout v45m
```

### 新功能用分支开发

```
开发新功能前
    |
git checkout -b feature/批量处理
    |
在分支上开发、测试
    |
测试OK → git merge到main → git push
测试失败 → git checkout main 回到稳定版本
```

### 新对话恢复方法

如果老对话token用完或挂了：

```bash
# 新对话里执行
git clone https://github.com/用户名/项目名.git
cd 项目名
git checkout v45m  # 切换到稳定版本
pnpm install
pnpm dev
```

---

## 十四、安全提醒

### 不要在对话里暴露敏感信息

**错误做法**：

"Token是：ghp_xxxxxxxxxxxx，帮我推送代码"

**正确做法**：
- 使用 Manus 的 Secrets 功能存储敏感信息
- 用环境变量引用，不明文写在命令里

---

## 十五、V48经验补充

### Markdown解析器开发经验

**分步实现原则**：

```
Step 3: 先做粗体/斜体（最简单）
    | 验收
Step 4: 再做表格（中等复杂）
    | 验收
Step 5: 最后做列表/引用/分隔线（相互独立）
```

**正则表达式测试**：让Manus先给出正则表达式和测试用例，确认匹配正确后再集成。

"帮我写一个正则，匹配Markdown的粗体语法（`**文本**`），
给出3个正例和3个反例的测试结果。"

### 文件上传功能开发经验

**前后端分离开发**：

```
Step 7: 先做后端接口
    | 用curl测试验收
Step 8: 再做前端界面
    | 界面测试验收
Step 9: 最后做AI调用集成
```

**curl测试命令示例**：

```bash
# 测试文档上传
curl -X POST http://localhost:3000/api/batch/upload-files \
  -F "files=@test.pdf"

# 测试图片上传
curl -X POST http://localhost:3000/api/batch/upload-files \
  -F "files=@test.png"
```

### 类型定义扩展经验

**问题**：需要扩展现有类型定义（如llm.ts的mime_type）

**安全做法**：

1. 先确认现有代码哪些地方用到这个类型
2. 评估改动影响范围
3. 选择最小改动方案（从枚举改string比添加枚举值更灵活）

```
"llm.ts的mime_type目前是枚举类型，我想支持更多文件格式。
帮我：
1. 列出所有用到mime_type的地方
2. 评估改成string类型的影响
3. 如果影响可控，帮我改"
```

### 多阶段功能开发经验（V48 M5计划）

计划中的共享文件模式：

```
Step 13: 前端新增共享文件上传区域
Step 14: 后端接收共享文件参数
Step 15: 后端发送时合并文件
```

关键设计决策：
- 共享文件和独立文件可同时使用
- 单任务文件总数不超过10个（API限制）
- 前端需要显示文件总数计数

---

## 十六、V48关键教训总结

| 版本 | 教训 |
|------|------|
| V48 | Markdown解析要分元素逐步实现，不要一次性全做 |
| V48 | 文件上传要先用curl测接口，再接前端 |
| V48 | 类型定义扩展前要评估影响范围 |
| V48 | 文件处理要考虑排序（中文文件名排序） |
| V48 | API限制（如文件数上限）要在前端做检查提示 |

---

## 十七、Git Rebase/Merge 覆盖改动问题

### 问题现象

明明已经完成并提交的改动，在后续的 Checkpoint 保存过程中消失了。

**V53 实际案例**：
- 已完成：把版本号从右下角改到右上角（`bottom-2` → `top-2`）
- 已提交：git commit 成功
- 结果：保存 Checkpoint 时 git rebase 解决冲突，改动被覆盖，又变回 `bottom-2`

### 原因分析

Manus 在保存 Checkpoint 时可能执行 git rebase 或 merge 操作。如果有冲突，自动解决冲突的过程中可能丢失最近的改动。

### 预防措施

**1. Checkpoint 后验证提交历史**

```bash
git log --oneline -5      # 确认提交还在
git diff HEAD~1           # 查看最新提交内容是否正确
```

**2. 发布后验证功能**
- 用无痕模式访问正式环境
- 确认关键改动是否生效
- 这也是为什么要加版本号显示——一眼确认版本

**3. 发现改动丢失时**

```bash
git reflog                # 查找丢失的提交
git cherry-pick <commit>  # 恢复丢失的改动
```

或者直接让 Manus 重新执行一遍改动。

### 经验教训

| 教训 | 说明 |
|------|------|
| 不要假设提交就安全 | Checkpoint 过程可能覆盖改动 |
| 发布后必须验证 | 访问正式环境确认功能生效 |
| 版本号显示很重要 | 一眼确认当前运行的是哪个版本 |

---

## 十八、任务书标准格式：大路书 + 小路书

### 背景问题

多轮对话中容易"迷失方向"：
- Manus 不知道当前任务在整体中的位置
- 我们自己也可能忘了做到哪一步了
- 任务之间缺乏连贯性，容易重复或遗漏

### 解决方案

每个任务书都必须包含三层导航：

1. **宏观大路书**：当前在做哪个版本（如 V49-V51）
2. **版本小路书**：当前版本做到哪一步了
3. **具体任务**：本次要做什么

### 标准任务书模板

```markdown
# VXX Step Y 任务书：[任务标题]

---

## 宏观背景（V49-V51）

| 版本 | 功能 | 状态 |
|------|------|------|
| V49 | [功能描述] | ✅ 已发布 |
| **V50** | **[功能描述]** | **🔄 进行中** |
| V51 | [功能描述] | ⏳ 待开始 |

### VXX 小路书进度

| Step | 任务 | 状态 |
|------|------|------|
| 1 | [任务描述] | ✅ 完成 |
| 2 | [任务描述] | ✅ 完成 |
| 3 | [任务描述] | ⬅️ **当前任务** |
| 4 | [任务描述] | ⏳ 待执行 |

---

## 任务：[具体任务描述]

### 背景
[为什么要做这个]

### 目标
[做完是什么状态]

### 具体要求
1. [第一步]
2. [第二步]
3. [第三步]

### 不要做
- [明确排除的事项]

### 验收标准
- [ ] [检查项1]
- [ ] [检查项2]
- [ ] pnpm build 无报错

### 参考
- 文件位置：xxx
```

### 状态标记规范

| 标记 | 含义 | 使用场景 |
|------|------|------|
| ✅ | 已完成 | 版本已发布 / Step已完成 |
| 🔄 | 进行中 | 当前正在做的版本 |
| ⏳ | 待开始 | 还没开始的版本或Step |
| ⬅️ 当前任务 | 当前Step | 标记本次任务书对应的Step |

### 实际示例

```markdown
# V50 Step 3 任务书：添加复制按钮

---

## 宏观背景（V49-V51）

| 版本 | 功能 | 状态 |
|------|------|------|
| V49 | 版本标识 + max_tokens配置 + 截断检测 | ✅ 已发布 |
| **V50** | **模板格式说明 + 复制按钮** | **🔄 进行中** |
| V51 | 文档转文字 + 来源标签 | ⏳ 待开始 |

### V50 小路书进度

| Step | 任务 | 状态 |
|------|------|------|
| 1 | 设计5种模板的格式说明文案 | ✅ 完成 |
| 2 | 前端：添加模板说明显示区域 | ✅ 完成 |
| 3 | 前端：添加复制按钮 | ⬅️ **当前任务** |
| 4 | 测试 + Checkpoint + 发布 | ⏳ 待执行 |

---

## 任务：为模板格式说明区域添加一键复制按钮

### 背景
V50 Step 2 已完成模板说明显示区域，现在需要添加复制按钮...

[后续具体内容]
```

### 好处

1. **Manus 有全局视野**：知道自己在做什么、为什么做
2. **我们不会迷失**：随时能看清整体进度
3. **便于交接**：换对话/换人也能快速接上
4. **任务书可追溯**：每个任务书都是完整的上下文快照

### 注意事项

- 宏观大路书范围通常是 3-5 个版本（太多了看不过来）
- 小路书通常是 3-6 个 Step（太细了没必要）
- 任务书用 `.md` 格式保存，方便复制粘贴

---

## 十九、Git 推送必须验证（强制规则）

### 血泪教训

V52 开发了 13 个 Step，创建了 6 个核心模块，Manus 每次都报告"已推送到 GitHub"、"Checkpoint 已保存"。

结果：沙盒重置后发现，这些代码从未真正推送到 GitHub，全部丢失。

### 强制规则

每次 `git push` 后，必须执行验证命令：

```bash
# 推送后立即验证
git push origin main

# 验证远程仓库是否真的有这个提交
git log origin/main --oneline -3

# 验证关键文件是否在远程
git ls-tree origin/main --name-only server/core/
```

**如果验证失败，必须立即报告，不能继续下一步！**

### 任务书强制要求

从现在开始，每个任务书的验收标准必须包含：

```markdown
### 验收标准
- [ ] ... 其他验收项 ...
- [ ] `git push origin main` 执行成功
- [ ] `git log origin/main --oneline -1` 显示本次提交
- [ ] **截图或复制验证命令的输出**
```

### Manus 响应模板

完成任务后，Manus 必须提供以下格式的确认：

```
✅ Step X.X 完成

Git 推送验证：
$ git log origin/main --oneline -3
abc1234 本次提交信息
def5678 上次提交信息
...

确认文件存在：
$ git ls-tree origin/main --name-only server/core/
codeSandbox.ts ← 新增
errorFormatter.ts ← 新增
...
```

**没有这个验证输出，不算完成！**

---

## 二十、版本号管理（强制规则）

### 血泪教训

V52 版本号被用了两次：
- 1月16日 V52：截断检测功能
- 1月17日 V52：AI代码生成功能（版本号冲突）

Git 历史混乱，新代码覆盖旧代码，无法追溯。

### 强制规则

**1. 开始新版本前，必须确认版本号未被使用：**

```bash
# 检查版本号是否已存在
git log --oneline --all | grep "V52"
git tag -l | grep "v52"
```

**2. 版本号命名规范：**

| 场景 | 命名 | 示例 |
|------|------|------|
| 大功能 | VXX | V53 |
| 功能迭代 | VXX.Y | V53.1 |
| 热修复 | VXX.Y.Z | V53.1.1 |

**3. 关键版本必须打 Git Tag：**

```bash
# 版本完成后打 tag
git tag -a v53 -m "V53: AI代码生成Word系统"
git push origin v53

# 验证 tag 存在
git ls-remote --tags origin | grep v53
```

### 版本号检查清单

开始新版本前：
- [ ] 确认版本号未被使用（git log 搜索）
- [ ] 确认前一个版本已打 tag
- [ ] 在顶层设计文档中声明版本号

---

## 二十一、沙盒重置防护

### 血泪教训

Manus 沙盒重置后，本地所有文件丢失。如果代码没有推送到 GitHub，就彻底没了。

### 强制规则

**1. 每完成一个 Step，必须推送并验证：**

不能攒多个 Step 一起推送。每个 Step 完成后立即：

```bash
git add .
git commit -m "V53 Step X.X: 具体内容"
git push origin main
# 验证（见第十九条）
```

**2. 长任务中途也要推送：**

如果一个 Step 需要超过 30 分钟，中途也要提交：

```bash
git add .
git commit -m "V53 Step X.X: WIP - 进度说明"
git push origin main
```

**3. 看到"重置计算机"警告时：**

如果 Manus 显示"正在重置计算机"，必须：
- 立即停止当前操作
- 确认最后一次 git push 是否成功
- 重置后第一件事：`git log origin/main --oneline -5` 确认代码还在

---

## 二十二、不信任原则

### 核心原则

**不要相信 Manus 说的"已完成"、"已推送"、"已保存"。**

必须通过以下方式验证：

| Manus 说 | 你要验证 |
|------|------|
| "已推送到 GitHub" | `git log origin/main --oneline -3` |
| "文件已创建" | `ls -la 文件路径` |
| "测试全部通过" | 看具体的测试输出 |
| "Checkpoint 已保存" | 在界面上确认能看到 Checkpoint |
| "构建成功" | `pnpm build` 的完整输出 |

### 任务书结尾标准模板

```markdown
### 完成确认（必须提供）

1. Git 验证：
$ git log origin/main --oneline -3 [粘贴输出]
2. 文件验证：
$ ls -la server/core/ [粘贴输出]
3. 构建验证：
$ pnpm build [粘贴最后几行输出]

以上验证全部通过，Step X.X 完成。
```

### 附：V52 事故总结

**时间线**：

1. 1月16日：V52（截断检测）完成并推送
2. 1月17日：开始新的 V52（AI代码生成），版本号冲突
3. 1月17日：完成 13 个 Step，Manus 每次都报告"已推送"
4. 1月17日：沙盒重置
5. 1月17日：发现代码全部丢失，GitHub 上只有1月16日的 V52

**根本原因**：

1. **版本号重复使用** - 没有检查版本号是否已存在
2. **推送未验证** - Manus 说推送了就信了，没有验证远程仓库
3. **Checkpoint 不等于 Git** - Manus 的 Checkpoint 是内部状态，不是代码备份
4. **沙盒重置无保护** - 重置前没有确认代码已安全

**损失**：
- 6 个核心模块代码
- 约 1000+ 行代码
- 约 4-6 小时开发时间

**预防措施**：见上述第十九、二十、二十一、二十二条规则。

---

## 二十三、最可靠的验证方法：直接看 GitHub 网页

### 血泪教训后的顿悟

V60 恢复代码时，我们折腾了半天各种 git 命令验证，最后发现：

**直接打开浏览器看 GitHub 网页最简单、最可靠！**

Manus 的命令行输出可能造假，但 GitHub 网页不会骗人。

### 验证步骤

1. 打开浏览器，访问仓库地址：`https://github.com/wanghaoen2000/feedback-mvp`
2. 检查最新提交：
   - 看页面顶部的提交信息
   - 确认是你期望的版本（如 V60: AI代码生成Word系统完整版）
   - 确认时间是刚才（如 3 minutes ago）
3. 检查关键目录：
   - 点击进入 `server/core/` 目录
   - 确认核心文件都在
4. 检查 Tags：
   - 点击页面上的 "Tags" 链接
   - 确认版本标签存在（如 v60）

### 什么时候必须用网页验证

| 场景 | 必须网页验证 |
|------|------|
| 重大版本发布 | 是 |
| 代码从 Checkpoint 恢复后 | 是 |
| 怀疑 Manus 造假时 | 是 |
| 日常小改动 | 否，命令行验证即可 |

### 截图留证

重大版本发布后，建议截图保存 GitHub 页面，作为"代码确实上传成功"的证据。

---

## 二十四、V60 事故恢复总结

### 事件经过

1. V52 开发了 13 个 Step，Manus 每次都报告"已推送"
2. 沙盒重置，以为代码全丢了
3. 发现 Checkpoint 可以恢复
4. 从 Checkpoint 恢复后，代码回来了
5. 直接改版本号为 V60，强制推送到 GitHub
6. 打开 GitHub 网页确认代码确实存在

### 关键决策

| 问题 | 错误做法 | 正确做法 |
|------|------|------|
| 版本号混乱怎么办 | 纠结历史、尝试修复 | 直接跳到 V60，不管历史 |
| 和远程可能冲突 | 各种检查、小心翼翼 | `git push --force` 强制覆盖 |
| 怎么验证代码真的上传了 | 命令行各种 git 命令 | 直接打开 GitHub 网页看 |

### 经验总结

1. **简单粗暴有时最有效** - 不要把问题搞复杂
2. **直接看网页最可靠** - 不要只信命令行输出
3. **Checkpoint 可以救命** - 沙盒重置不等于代码丢失
4. **版本号可以跳** - V52 乱了就直接跳到 V60

### 附：V60 验证截图要点

GitHub 网页应该显示：

```
最新提交: V60: AI代码生成Word系统完整版（从Checkpoint恢复）
时间: X minutes ago
提交数: 168 Commits
Tags: 2 tags (包含 v60)

server/ 目录最后更新: Checkpoint: V52 Step 5.2: 后端整合完整流程
client/ 目录最后更新: V60: AI代码生成Word系统完整版（从Checkpoint恢复）
```

看到这些，代码就是安全的！

---

## 二十五、V65 变量作用域血泪教训

### 问题经过

V65 开发「指定任务」功能时，修改后端代码将 `start` 和 `end` 变量定义移到 `else` 分支内：

```javascript
// 修改前
const start = startNumber || 1;
const end = endNumber || 1;
let taskNumbers: number[];
if (inputTaskNumbers) {
  taskNumbers = inputTaskNumbers;
} else {
  // 使用 start 和 end
}

// 修改后（有问题）
let taskNumbers: number[];
if (inputTaskNumbers) {
  taskNumbers = inputTaskNumbers;
} else {
  const start = startNumber || 1;  // 移到这里
  const end = endNumber || 1;      // 移到这里
  // ...
}
```

测试时返回 502/503 错误，服务器崩溃。

### 根因分析

有两处代码在 if/else 分支外引用了 `start` 和 `end`：

```javascript
// 第 245 行
console.log(`任务范围: ${start} - ${end}`);  // ReferenceError!

// 第 289-290 行
sendEvent('start', { startNumber: start, endNumber: end });  // ReferenceError!
```

当走 if 分支（指定任务模式）时，`start` 和 `end` 未定义，导致 ReferenceError。

### 解决方案

使用 `taskNumbers` 数组的首尾元素替代：

```javascript
const firstTask = taskNumbers[0];
const lastTask = taskNumbers[taskNumbers.length - 1];
console.log(`任务范围: ${firstTask} - ${lastTask} (共 ${taskNumbers.length} 个)`);
```

### 强制规则

修改变量作用域时，必须执行全局搜索：

```bash
# 搜索变量的所有引用
grep -rn "start" server/batch/batchRoutes.ts
grep -rn "end" server/batch/batchRoutes.ts
```

任务书必须包含：

```markdown
### 变量作用域检查

如果本次改动涉及变量定义位置变更，请执行：

1. `grep -rn "变量名" 文件路径` 列出所有引用
2. 确认每个引用位置在新作用域内仍可访问
3. 如果有引用在作用域外，要同步修改
```

---

## 二十六、502/503 错误排查流程

### 区分错误类型

| 错误码 | 含义 | 常见原因 |
|------|------|------|
| 502 Bad Gateway | 后端服务崩溃 | 代码错误（语法错误、运行时错误） |
| 503 Service Unavailable | 服务不可用 | 代码未发布、服务器启动中、配置问题 |

### 排查步骤

**1. 检查代码是否已发布**

如果版本号显示的是老版本，说明代码没有发布：

```bash
# 查看本地和远程版本
git log --oneline -3
git log origin/main --oneline -3
```

**2. 检查服务器是否启动**

```bash
lsof -i :3000
# 或
curl http://localhost:3000/api/health
```

**3. 查看服务器日志**

```bash
pnpm dev 2>&1 | tail -100
```

**4. 检查代码编译**

```bash
pnpm build
pnpm typecheck
```

### 快速定位技巧

如果是改动后立即出错，重点检查：
- 变量作用域变更
- 函数参数变更
- 类型定义变更
- 导入/导出变更

---

## 二十七、发布流程确认

### Manus 特殊性

- `git push` 只是推送到 GitHub
- 代码要生效，需要在 Manus 界面点击 Publish
- 版本号不变 = 代码没发布

### 验证清单

每次改动后，必须确认：

- [ ] `git push origin main` 成功
- [ ] `git log origin/main` 显示最新提交
- [ ] 在 Manus 界面点击 Publish
- [ ] 等待发布完成
- [ ] 访问正式环境验证功能
- [ ] 确认版本号已更新

### 版本号检查

如果正式环境版本号没变：
1. 代码可能没 push 成功
2. 可能没点 Publish
3. Publish 可能失败了

用无痕模式访问正式环境，强制刷新后检查版本号。

---

## 二十八、Checkpoint 和 Git Push 的正确顺序（强制规则）

### 血泪教训

V66 开发完成后，Manus 报告"已推送到 GitHub"、"Checkpoint 已保存"。但点击 Publish 时发现按钮是灰色的，无法发布。

检查后发现：Checkpoint 显示 "No changes to commit"。

原因：Manus 先执行了 `git push`，然后再保存 Checkpoint。此时本地没有未提交的改动，Checkpoint 系统认为"没有变更需要保存"。

### 关键认知

```
Manus Checkpoint ≠ Git Commit

- Checkpoint：Manus 平台的内部状态快照，用于 Publish
- Git Commit：代码版本控制，推送到 GitHub

两者是独立的系统！
```

### 正确顺序（强制规则）

```
代码改完
    |
1. 先保存 Checkpoint（确保 Publish 可用）
    |
2. 再 git add / commit / push（代码备份到 GitHub）
    |
3. 点击 Publish 发布
```

### 错误顺序（会导致无法发布）

```
代码改完
    |
1. 先 git add / commit / push  ← 错误！
    |
2. 再保存 Checkpoint  ← 此时显示 "No changes to commit"
    |
3. Publish 按钮灰色，无法发布  ← 卡住了！
```

### 任务书强制要求

从现在开始，每个任务书的验收标准必须按以下顺序：

```markdown
### 验收标准
- [ ] pnpm build 无报错
- [ ] 功能测试通过
- [ ] **保存 Checkpoint**（必须在 git push 之前！）
- [ ] git push origin main 成功
- [ ] git log origin/main 显示本次提交
- [ ] 点击 Publish 发布
- [ ] 访问正式环境验证功能
```

### 如果顺序搞反了怎么办

如果已经先 push 了，Checkpoint 显示 "No changes"，有两种解决方法：

**方法1：随便改点东西触发变更**

```bash
# 加个空行或注释
echo "" >> server/batch/batchRoutes.ts

# 然后保存 Checkpoint
```

**方法2：让 Manus 恢复 Checkpoint 后重新操作**

### Manus 响应模板更新

完成任务后，Manus 必须按以下顺序提供确认：

```
✅ Step X.X 完成

1. 构建验证：
$ pnpm build [粘贴最后几行输出]

2. Checkpoint 保存：
已保存 Checkpoint: "V66 Step X: xxx"

3. Git 推送验证：
$ git push origin main
$ git log origin/main --oneline -3
abc1234 本次提交信息
...

4. 请点击 Publish 发布，然后访问正式环境验证。
```

### 经验教训

| 教训 | 说明 |
|------|------|
| Checkpoint 和 Git 是独立系统 | 不要混为一谈 |
| 先 Checkpoint 再 Push | 顺序不能反 |
| Push 后 Checkpoint 会失效 | 因为本地没有"变更"了 |
| Publish 依赖 Checkpoint | 没有 Checkpoint 就没法 Publish |

---

## 二十九、版本号更新检查（强制规则）

### 问题现象

V67 修复完成并发布后，右上角版本号仍然显示 V66。

### 原因

版本号显示依赖 `generate-version.cjs` 文件，这个文件需要手动更新，不会自动变。

### 强制规则

每次发布新版本时，必须更新 `generate-version.cjs` 中的版本号！

```javascript
// generate-version.cjs 中的版本号
const VERSION = 'V67';  // ← 每次发布前必须手动改这里
```

### 版本发布检查清单

每次版本发布时，按以下顺序检查：

1. [ ] 功能代码修改完成
2. [ ] 更新 `generate-version.cjs` 中的版本号 ← 容易忘！
3. [ ] `pnpm build` 无报错
4. [ ] 保存 Checkpoint
5. [ ] `git push origin main`
6. [ ] 点击 Publish
7. [ ] 访问正式环境，确认右上角版本号已更新

### 任务书模板更新

从现在开始，每个任务书的验收标准必须包含：

```markdown
### 验收标准
- [ ] ... 其他验收项 ...
- [ ] 更新 `generate-version.cjs` 版本号为 VXX
- [ ] 保存 Checkpoint
- [ ] git push origin main
- [ ] 点击 Publish
- [ ] **确认右上角版本号显示 VXX**
```

### 经验教训

| 教训 | 说明 |
|------|------|
| 版本号不会自动更新 | 必须手动修改 `generate-version.cjs` |
| 发布后必须验证 | 看右上角版本号是否正确 |
| 版本号是最直观的验证 | 版本号对了才能确认代码真的发布了 |

---

## 三十、COLLAB.md 协作看板机制（V131起）

### 背景

V129-V131 气泡图字体问题的排查涉及 Claude（写代码）和 Manus（部署环境）反复协作，口头描述任务容易遗漏细节。从 V131 开始引入 `COLLAB.md` 文件作为标准化协作看板。

### 机制说明

`COLLAB.md` 存放在项目根目录，包含两个核心区域：

**1. 版本发布记录**

每个版本一个条目，包含：
- 版本号和日期
- 改动内容摘要
- 涉及的文件列表
- 部署状态（待部署/已部署）

**2. Manus 部署任务书**

Claude 在需要部署时，会在 `COLLAB.md` 底部写一个部署任务书，格式如下：

```markdown
## 🚀 部署任务：V1XX

### 改动内容
- xxx
- xxx

### 涉及文件
- client/src/pages/xxx.tsx
- server/xxx.ts

### 部署步骤
1. 合并分支到 main
2. 更新 generate-version.cjs 版本号为 V1XX
3. pnpm build
4. 保存 Checkpoint
5. git push origin main
6. 点击 Publish

### 验收标准
- [ ] 右上角版本号显示 V1XX
- [ ] xxx 功能正常
```

### 经验教训

| 教训 | 说明 |
|------|------|
| 书面化比口头好 | 任务书写清楚了，Manus执行率明显提高 |
| 验收标准要具体 | "功能正常"太模糊，要写"点击XX按钮，显示XX内容" |
| 状态要及时更新 | 部署后应将状态改为"已部署"（目前这步经常漏掉） |

---

## 三十一、Claude分支开发模式（V72-V100经验）

### 模式说明

V72-V100 期间采用了 Claude 在独立分支上开发的模式：

```
Claude 在 claude/xxx-xxxxx 分支上写代码
→ 完成后 merge 到 main
→ Manus 更新版本号 + build + checkpoint + push
→ 临时分支用完即删
```

### 注意事项

| 注意 | 说明 |
|------|------|
| 分支名自动生成 | Claude 创建的分支名格式为 `claude/{描述}-{随机ID}` |
| 合并后立即删除 | `git push origin --delete claude/xxx` 避免分支堆积 |
| 不要保留太久 | 长期未合并的分支容易与 main 冲突 |
| 历史分支可清理 | `claude/review-project-overview-1VIxH` 是 V72-V100 的历史分支，可安全删除 |

---

## 三十二、Checkpoint Rebase 对 Git 历史的影响

### 问题

Manus 的 Checkpoint 机制使用 rebase，会覆盖 git log 中较早的 commit 记录。

实际影响：feedback-mvp 项目的 git log 只保留了 V139 之后的约 60 条 commit，V1-V138 的 commit 全部被覆盖。

### 恢复方法

`git reflog` 不受 rebase 影响，完整保留了所有历史操作（本项目中有 574 条）。

```bash
# 查看完整历史
git reflog --oneline | tail -50

# 恢复到某个历史版本（谨慎操作）
git checkout HEAD@{N}
```

### 预防措施

| 措施 | 说明 |
|------|------|
| 打 tag 保留里程碑 | 重要版本打 tag（如 v60、v64），tag 不受 rebase 影响 |
| 不依赖 git log 追溯 | 用 reflog 或文档记录版本历史 |
| 迭代记录文档是正本 | Git 历史可能丢，文档不会丢 |

---

## 三十三、部署流程标准化（V131起）

### 完整部署流程

基于 V131-V152 的实战经验，标准部署流程如下：

1. Claude 完成代码开发（在分支或直接在 main 上）
2. Claude 更新 COLLAB.md（写部署任务书）
3. Manus 执行：
   - a. 合并分支到 main（如有分支）
   - b. 更新 `generate-version.cjs` 版本号
   - c. `pnpm build`（确认无报错）
   - d. 保存 Checkpoint
   - e. `git push origin main`
   - f. 点击 Publish
4. 验收：
   - a. 访问正式环境
   - b. 确认右上角版本号
   - c. 测试核心功能
5. 后续（目前经常漏掉）：
   - a. 更新 COLLAB.md 状态为"已部署"
   - b. 删除临时分支

### 批量部署

V141-V152 期间验证了分批部署模式：

| 场景 | 做法 |
|------|------|
| 多个小版本 | 可以合并为一个部署任务（如 V148+V149） |
| 有风险的版本 | 单独部署，验收通过后再部署下一个 |
| Bug修复版本 | 紧急部署，不用等其他功能 |

---

## 三十四、V68-V152 新增的Manus协作经验

### 1. 信息收集型任务

V152 时首次给 Manus 下发了"纯信息收集"任务（不改代码，只运行命令并汇报结果）。

**任务类型：**
- 运行 git 命令还原版本历史
- 检查分支状态和部署情况
- 确认环境配置

**经验：**
- 这类任务 Manus 执行效果好，因为目标明确、不涉及代码修改
- 适合在对项目状态不确定时先做排查

### 2. 沙箱环境限制的排查

V129-V131 气泡图字体问题暴露了沙箱环境的特殊性：

| 限制 | 表现 | 解决 |
|------|------|------|
| 无法访问 /usr/share/fonts | resvg 找不到字体，文字消失 | 复制字体到项目 fonts/ 目录 |
| 系统字体扫描慢 | loadSystemFonts 导致性能问题 | 设为 false |

**教训**：在 Manus 环境中开发时，不要假设系统级资源（字体、证书、工具链）可用。如果功能依赖系统资源，要在任务书中明确提醒。

### 3. 数据库迁移任务

V112（后台任务表）和 V148（作业管理表）都涉及数据库迁移。

**任务书写法：**

```markdown
### 数据库迁移
1. 在 drizzle/ 目录新增迁移文件 0009_homework_management.sql
2. 在 drizzle/schema.ts 中添加新表定义
3. 执行 pnpm drizzle-kit push
4. 验证：连接数据库确认表已创建
```

**注意：**
- 迁移文件编号要递增，不能跳号
- 字段类型要明确写（VARCHAR/MEDIUMTEXT/ENUM等）
- 默认值和约束也要在任务书中写清楚

---

## 三十五、更新任务书模板（V152版）

基于 V131-V152 的经验，更新后的任务书模板：

```markdown
# 部署任务：V{版本号}

## 改动概述
一句话描述本次改动的目的。

## 详细改动
1. xxx
2. xxx

## 涉及文件
- [ ] client/src/pages/xxx.tsx（新增/修改）
- [ ] server/xxx.ts（修改）
- [ ] drizzle/xxxx.sql（新增，需要数据库迁移）

## 数据库迁移（如有）
- 新增表/字段描述
- 迁移命令

## 部署步骤
1. [ ] 合并分支到 main（如有分支：`git merge claude/xxx`）
2. [ ] 删除临时分支（`git push origin --delete claude/xxx`）
3. [ ] 更新 generate-version.cjs 版本号为 V{版本号}
4. [ ] pnpm build（确认无报错）
5. [ ] 保存 Checkpoint
6. [ ] git push origin main
7. [ ] 点击 Publish

## 验收标准
- [ ] 右上角版本号显示 V{版本号}
- [ ] {具体功能验证点1}
- [ ] {具体功能验证点2}
- [ ] COLLAB.md 状态更新为"已部署" ← 不要忘！
```

---

*文档版本：V152 | 最后更新：2026年2月10日*
