# 技术备忘

本文档记录项目开发过程中的关键技术细节、踩过的坑、以及部署注意事项。既用于本项目后续维护，也可作为其他项目的参考。

---

## 一、踩过的坑

### 1. 回滚丢代码（V16）

**问题**：在没有版本管理的情况下回滚，导致部分功能代码丢失，不得不重新实现。

**教训**：
- 每次迭代前必须备份
- 应该使用Git进行版本管理
- 回滚前确认要回到哪个状态，备份当前状态

**通用建议**：任何项目，哪怕是快速原型，也要有基本的版本管理。

---

### 2. 第三方API不稳定（V5→V15）

**问题**：最初选用的神马中转API不稳定，后来不得不切换到DMXapi。

**教训**：
- 选API不只看价格，还要看稳定性和口碑
- 最好有备用API方案
- API调用要有重试机制

**通用建议**：依赖第三方服务时，要考虑服务不可用的情况，设计降级方案。

---

### 3. AI转述效果差（V23）

**问题**：最初的设计是让AI先"理解"V9路书，然后再生成内容。结果生成质量不稳定。

**解决方案**：直接把路书原文作为系统提示词，不做任何转述。

**教训**：
- 有时候简单粗暴比精心设计更有效
- 给AI的指令越直接越好，中间环节越少越好

**通用建议**：如果有现成的规范文档，直接用原文，不要让AI"理解后转述"。

---

### 4. 多余的处理步骤（V20→V26）

**问题**：V20实现了录音转文字的分段压缩功能，想着能减少token消耗。结果多一步处理多一步出错，还增加了复杂度。

**解决过程**：
- V20：实现分段压缩
- V25：改成一次性压缩
- V26：干脆取消压缩，直接用原文

**教训**：
- 能省的步骤就省
- 不要过早优化
- 简单的方案往往更可靠

**通用建议**：在功能验证阶段，先用最简单的方案跑通，优化的事后面再说。

---

### 5. max_tokens设置不够（V21）

**问题**：whatai.ts 默认 max_tokens 设置为8000，导致长文档输出被截断。

**解决方案**：改为16000。

**教训**：
- AI输出长度限制要根据实际需求设置
- 输出被截断不会报错，容易被忽略

**通用建议**：做AI生成类项目，要测试长内容场景，确保max_tokens够用。

---

### 6. 同步调用超时（V22）

**问题**：长文档生成时，普通的HTTP请求会超时（Manus平台有超时限制）。

**解决方案**：改用SSE（Server-Sent Events）流式输出，边生成边返回。

**教训**：
- 耗时长的操作不能用普通的请求-响应模式
- 流式输出不仅解决超时，用户体验也更好（能看到实时进度）

**通用建议**：AI生成类项目，优先考虑流式输出方案。

---

## 二、关键实现细节

### 1. 流式输出（SSE）

**技术方案**：使用 Server-Sent Events 实现流式返回。

**核心实现代码**：位于 `server/whatai.ts` 的 `invokeWhatAIStream` 函数（第191-318行）

```typescript
export async function invokeWhatAIStream(
  messages: WhatAIMessage[],
  options?: { model?: string; max_tokens?: number; temperature?: number; timeout?: number; retries?: number; },
  config?: APIConfig,
  onChunk?: (chunk: string) => void
): Promise<string> {
  // ... 配置初始化 ...

  const response = await fetch(`${baseUrl}/chat/completions`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model,
      messages,
      max_tokens,
      temperature,
      stream: true, // 关键：启用流式输出
    }),
    signal: controller.signal,
  });

  // 读取流式响应
  const reader = response.body?.getReader();
  const decoder = new TextDecoder();
  let fullContent = '';
  let buffer = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    buffer += decoder.decode(value, { stream: true });

    // 处理SSE格式的数据（以 "data: " 开头）
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = line.slice(6).trim();
        if (data === '[DONE]') continue;

        const parsed = JSON.parse(data);
        const content = parsed.choices?.[0]?.delta?.content || '';
        if (content) {
          fullContent += content;
          if (onChunk) onChunk(content); // 回调通知
        }
      }
    }
  }
  return fullContent;
}
```

**前端如何接收**：前端使用 tRPC 的 mutation 调用，服务端内部使用流式处理，但返回给前端的是完整结果。流式输出主要用于：
1. 防止服务端超时（边生成边输出保持连接活跃）
2. 服务端日志实时打印进度点（`onChunk` 回调中 `process.stdout.write('.')`）

---

### 2. Google Drive上传

**技术方案**：通过 Google OAuth API 上传（早期曾使用 rclone，后已弃用）。

**核心代码位置**：`server/gdrive.ts`

**重试机制**：
- 最大重试次数：3次
- 重试间隔：2秒（固定）
- 上传后自动验证文件是否存在

---

### 3. 5个独立API端点

**设计思路**：把5个文档的生成拆分成5个独立的API端点，而不是一个大接口。

**好处**：
- 一个失败不影响其他
- 可以单独重试失败的步骤
- 便于定位问题

**端点列表**（位于 `server/routers.ts`）：

| 端点名称 | 功能 | 输入 | 输出 |
|---------|------|------|------|
| `feedback.generateFeedback` | 学情反馈 | 学生信息、笔记、录音 | 反馈内容、日期、上传结果 |
| `feedback.generateReview` | 复习文档 | 学生名、日期、反馈内容 | .docx文件上传结果 |
| `feedback.generateTest` | 测试本 | 学生名、日期、反馈内容 | .docx文件上传结果 |
| `feedback.generateExtraction` | 课后信息提取 | 学生名、日期、反馈内容 | .md文件上传结果 |
| `feedback.generateBubbleChart` | 气泡图 | 学生名、日期、反馈内容 | .png文件上传结果 |

---

### 4. 提示词策略

**做法**：直接使用V9路书原文作为系统提示词。

**实现逻辑**：
```typescript
// 如果有自定义路书，直接使用路书原文；否则使用默认提示词
const systemPrompt = config?.roadmap && config.roadmap.trim()
  ? config.roadmap
  : `默认提示词...`;
```

**要点**：
- 如果高级设置里有自定义路书，用自定义的
- 否则用代码里内置的默认路书
- 每个文档生成时添加边界限制，告诉AI只生成当前文档

**边界限制示例**：
```
【重要边界限制】
本次只需要生成学情反馈，不要生成复习文档、测试本或其他任何内容。
生成完学情反馈后立即停止，不要继续输出任何内容。
```

---

### 5. 气泡图生成流程

**流程**：AI生成SVG → resvg转换为PNG → 上传到Google Drive

**SVG转PNG使用的库**：**@resvg/resvg-js**（纯Rust实现，字体加载可控）

**转换代码位置**：`server/feedbackGenerator.ts`

```typescript
const { Resvg } = require('@resvg/resvg-js');

const opts = {
  font: {
    fontFiles: [
      path.join(__dirname, '../fonts/NotoSansCJKsc-Regular.otf'),
      path.join(__dirname, '../fonts/wqy-zenhei.ttc'),
    ],
    loadSystemFonts: false,
  },
};

const resvg = new Resvg(svgString, opts);
const pngData = resvg.render();
const pngBuffer = pngData.asPng();
```

**气泡图生成函数**：`generateBubbleChartSVGByAI`
- 使用流式输出调用AI
- AI直接按V9路书格式生成SVG代码
- 如果AI生成失败，返回一个简单的占位图

---

### 6. AI调用重试机制

**配置参数**：

| 参数 | 默认值 | 说明 |
|------|--------|------|
| 重试次数 | 2次 | 即最多调用3次（1次初始 + 2次重试） |
| 超时时间 | 10分钟（600000ms） | 复杂任务超时设置 |
| max_tokens | 64000 | 最大输出token数 |
| 重试间隔 | 递增延迟：`2000ms * 重试次数` | 第1次重试等2秒，第2次等4秒 |

**触发重试的条件**：
- 请求超时（AbortError）
- HTTP状态码非200（但排除401、403）
- 网络错误（fetch failed）

**不重试的情况**（直接抛出错误）：
- HTTP 401（未授权）
- HTTP 403（禁止访问，通常是余额不足）

**核心代码**（`server/whatai.ts` 第120-181行）：
```typescript
for (let attempt = 0; attempt <= maxRetries; attempt++) {
  if (attempt > 0) {
    console.log(`[WhatAI] 第${attempt}次重试...`);
    await delay(2000 * attempt); // 递增延迟
  }

  try {
    // ... 发起请求 ...

    if (!response.ok) {
      // 如果是余额不足等不可重试的错误，直接抛出
      if (response.status === 403 || response.status === 401) {
        throw new Error(`WhatAI API错误: ${response.status}`);
      }
      lastError = new Error(`WhatAI API错误: ${response.status}`);
      continue; // 尝试重试
    }
    // ... 处理响应 ...
  } catch (error) {
    // 如果是不可重试的错误，直接抛出
    if (error.message?.includes('403') || error.message?.includes('401')) {
      throw error;
    }
  }
}
```

---

## 三、部署相关

### 1. 环境信息

| 项目 | 值 |
|------|-----|
| 部署平台 | Manus |
| 包管理器 | pnpm |
| Node.js版本 | v22.13.0 |
| 数据库 | Manus内置MySQL（TiDB兼容） |
| 前端框架 | React 19 + TypeScript + Tailwind CSS 4 |
| 后端框架 | Node.js + tRPC + Express + Drizzle ORM |

### 2. 关键配置文件

| 文件 | 说明 |
|------|------|
| `drizzle/schema.ts` | 数据库表结构定义 |
| `drizzle.config.ts` | Drizzle ORM配置 |
| `server/_core/env.ts` | 环境变量访问封装 |
| `server/whatai.ts` | AI API调用模块 |
| `server/gdrive.ts` | Google Drive上传模块 |
| `server/feedbackGenerator.ts` | 5个文档的生成逻辑 |

### 3. 环境变量配置

环境变量由Manus平台自动注入，主要包括：

| 变量名 | 说明 |
|--------|------|
| `DATABASE_URL` | MySQL/TiDB连接字符串 |
| `JWT_SECRET` | Session cookie签名密钥 |
| `VITE_APP_ID` | Manus OAuth应用ID |
| `OAUTH_SERVER_URL` | Manus OAuth后端地址 |
| `OWNER_OPEN_ID` | 项目所有者的OpenID |
| `BUILT_IN_FORGE_API_URL` | Manus内置API地址 |
| `BUILT_IN_FORGE_API_KEY` | Manus内置API密钥 |

**注意**：不要在代码中硬编码这些值，也不要提交 `.env` 文件。

### 4. 部署步骤

**开发环境**：
```bash
cd /home/ubuntu/feedback-mvp
pnpm install
pnpm dev
```

**数据库迁移**：
```bash
pnpm db:push  # 执行 drizzle-kit generate && drizzle-kit migrate
```

**正式发布**：
1. 在Manus界面点击"Save Checkpoint"保存检查点
2. 点击"Publish"按钮发布
3. 发布后会获得一个 `xxx.manus.space` 域名

**Manus Publish做了什么**：
- 构建前端（`vite build`）
- 构建后端（`esbuild` 打包）
- 部署到Manus托管服务器
- 分配公网访问域名

**发布后的访问地址**：
- 格式：`https://xxx.manus.space`（xxx为自动生成或自定义的前缀）
- 可在Dashboard面板的Domains设置中修改域名前缀或绑定自定义域名

### 5. 数据库表结构

**表1：users（用户表）**

| 字段 | 类型 | 说明 |
|------|------|------|
| id | int | 主键，自增 |
| openId | varchar(64) | Manus OAuth标识，唯一 |
| name | text | 用户名 |
| email | varchar(320) | 邮箱 |
| loginMethod | varchar(64) | 登录方式 |
| role | enum('user','admin') | 角色，默认'user' |
| createdAt | timestamp | 创建时间 |
| updatedAt | timestamp | 更新时间 |
| lastSignedIn | timestamp | 最后登录时间 |

**表2：system_config（系统配置表）**

| 字段 | 类型 | 说明 |
|------|------|------|
| id | int | 主键，自增 |
| key | varchar(64) | 配置键名，唯一 |
| value | mediumtext | 配置值 |
| description | text | 配置说明 |
| updatedAt | timestamp | 更新时间 |

**system_config表存储的配置项**：

| key | 说明 | 默认值 |
|-----|------|--------|
| apiModel | AI模型名称 | claude-sonnet-4-5-20250929 |
| apiKey | API密钥 | sk-Wyfa... |
| apiUrl | API地址 | https://www.DMXapi.com/v1 |
| currentYear | 当前年份 | 2026 |
| roadmap | V9路书内容 | （空，需手动粘贴） |
| max_tokens | 最大输出token数 | 64000 |

---

## 四、停止按钮实现

**功能**：生成过程中显示红色"停止"按钮，点击后取消当前生成。

**实现方式**：
- 前端使用 `AbortController` 管理请求取消
- 设置 `isStopping` 状态标志
- 在每个步骤开始前检查是否需要停止

**核心代码**（`client/src/pages/Home.tsx`）：
```typescript
const abortControllerRef = useRef<AbortController | null>(null);
const [isStopping, setIsStopping] = useState(false);

// 停止生成
const handleStop = () => {
  setIsStopping(true);
  if (abortControllerRef.current) {
    abortControllerRef.current.abort();
  }
};

// 在生成流程中检查
if (isStopping) {
  // 清理状态并退出
  return;
}
```

---

## 五、文件存储路径

所有生成的文件按以下路径存储到Google Drive：

```
Mac/Documents/XDF/学生档案/
└── {学生姓名}/
    ├── 学情反馈/
    │   └── {学生姓名}{日期}阅读课反馈.md
    ├── 复习文档/
    │   ├── {学生姓名}{日期}复习文档.docx
    │   └── {学生姓名}{日期}测试文档.docx
    ├── 课后信息/
    │   └── {学生姓名}{日期}课后信息提取.md
    └── 气泡图/
        └── {学生姓名}{日期}气泡图.png
```

---

## 六、日志系统实现（V29-V32）

### 1. 日志模块设计

**文件位置**：`server/logger.ts`

**日志格式**：
```
============================================================
生成日志
============================================================
会话ID: 20260110124608_ro1b
开始时间: 2026/01/10 12:46:08
结束时间: 2026/01/10 12:48:30
学生: 张三
课次: 9
日期: 1月10日
最终结果: success
----------------------------------------
系统配置
----------------------------------------
API地址: https://www.DMXapi.com/v1
模型: claude-sonnet-4-5-20250929
max_tokens: 16000
----------------------------------------
输入摘要
----------------------------------------
笔记长度: 19442字符
录音长度: 53225字符
上次反馈长度: 13458字符
----------------------------------------
执行过程
----------------------------------------
[2026/01/10 12:46:08] [session] 开始生成会话
[2026/01/10 12:46:08] [学情反馈] 开始生成学情反馈
[2026/01/10 12:48:30] [学情反馈] 生成完成，耗时142.4秒，输出13335字符
----------------------------------------
步骤结果
----------------------------------------
✓ 学情反馈: success (142.4秒) - 13335字符
============================================================
```

**日志存储位置**：`/tmp/feedback-logs/`

**日志文件命名**：`{学生名}_{sessionId}.log`

### 2. 日志导出功能

**后端接口**：`exportLog` tRPC mutation

**实现流程**：
1. 根据学生名查找对应的日志文件
2. 读取日志内容
3. 上传到Google Drive的日志文件夹
4. 返回下载链接给前端

**踩坑记录**：
- 最初没有按学生名查找，并发时会返回错误学生的日志
- V41修复：前端传入学生名参数，后端根据学生名查找

---

## 七、GitHub仓库迁移（V33）

### 1. 背景

之前所有开发都在Manus单个对话里进行，存在问题：
- 无法多人协作
- 无法回溯历史版本
- 回滚时容易丢代码

### 2. 仓库信息

| 项目 | 值 |
|------|-----|
| 仓库地址 | https://github.com/wanghaoen2000/feedback-mvp |
| 默认分支 | main |
| 认证方式 | GITHUB_TOKEN |

### 3. Git配置

```bash
git config --global user.email "wanghaoen2000@users.noreply.github.com"
git config --global user.name "wanghaoen2000"
```

### 4. 工作流程

- 开发在Manus进行
- 每次迭代完成后推送到GitHub
- 需要回滚时可以从GitHub拉取

### 5. .gitignore 配置

```
# 依赖
node_modules/

# 构建输出
dist/

# 环境变量
.env
.env.local
.env.*.local

# 日志
logs/
*.log

# 系统文件
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/
```

**教训**：应该从项目一开始就使用版本控制，而不是等出问题了才补。

---

## 八、Google OAuth授权实现（V34-V38）

### 1. 背景

原来依赖Manus平台的rclone配置进行Google Drive授权，存在问题：
- token过期后需要重新部署
- 用户无法自己刷新授权

### 2. Google Cloud Console配置

**步骤1：创建项目**
- 项目名称：feedback-mvp
- Location：No organization

**步骤2：启用Google Drive API**
- APIs & Services → Library → 搜索 Google Drive API → Enable

**步骤3：配置OAuth同意屏幕**
- 类型：External
- App name：托福阅读学情反馈系统
- Scopes：`https://www.googleapis.com/auth/drive.file`
- Test users：添加自己的邮箱

**步骤4：创建OAuth凭据**
- 类型：Web应用
- 名称：feedback-mvp-web
- 已获授权的JavaScript来源：`https://xxx.manus.space`
- 已获授权的重定向URI：`https://xxx.manus.space/api/google/callback`

### 3. 后端实现

**新增端点**：

| 端点 | 功能 |
|------|------|
| `/api/google/auth` | 生成OAuth授权URL |
| `/api/google/callback` | 处理授权回调，保存token |
| `/api/google/disconnect` | 断开连接，清除token |

**Token存储**：保存到数据库 `system_config` 表

| key | 说明 |
|-----|------|
| google_access_token | 访问令牌 |
| google_refresh_token | 刷新令牌 |
| google_token_expiry | 过期时间 |

**Token刷新逻辑**：
```typescript
async function refreshGoogleToken() {
  const refreshToken = await getConfig('google_refresh_token');
  const response = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    body: new URLSearchParams({
      client_id: GOOGLE_CLIENT_ID,
      client_secret: GOOGLE_CLIENT_SECRET,
      refresh_token: refreshToken,
      grant_type: 'refresh_token',
    }),
  });
  // 保存新的access_token
}
```

### 4. 前端实现

高级设置区域新增：
- Google Drive连接状态显示
- 授权有效期显示
- "连接Google Drive"按钮
- "断开连接"按钮

### 5. 踩坑记录

**问题**：OAuth回调返回404

**原因**：代码只在Manus沙盒环境运行，没有发布到正式环境

**解决**：
1. 推送代码到GitHub
2. 在Manus平台点击Publish发布
3. 重新测试授权流程

---

## 九、并发问题修复（V39-V41）

### 1. 问题现象

同时为两个学生生成文档时，学生名互相污染：
- 标签页A：为"刘心瑶"生成
- 标签页B：为"文梁惠雅"生成
- 结果：日志显示刘心瑶，但文件存到了文梁惠雅的文件夹

### 2. 问题根因

`logger.ts` 使用了全局变量存储当前学生名：
```typescript
// ❌ 错误做法 - 全局变量
let currentStudentName = '';
let currentSessionId = '';

export function setStudent(name: string) {
  currentStudentName = name;  // 并发时会被覆盖！
}
```

### 3. 解决方案

每个请求创建独立的log对象，不使用全局变量：
```typescript
// ✅ 正确做法 - 每个请求独立的log对象
export function createLogSession(studentName: string) {
  const sessionId = generateSessionId();
  return {
    studentName,
    sessionId,
    steps: [],
    startStep: (name) => { ... },
    endStep: (name, success) => { ... },
    save: () => { ... }
  };
}

// 使用方式
const log = createLogSession(studentName);
log.startStep('学情反馈');
// ... 生成逻辑 ...
log.endStep('学情反馈', true);
await log.save();
```

### 4. 前端改进

添加当前生成学生名提示：
```
正在为「张三」生成 (2/5)...
```

**教训**：并发场景下不能用全局变量存储请求相关的状态。

---

## 十、气泡图中文乱码修复（V42）

### 1. 问题现象

气泡图里的中文显示为乱码方块。

### 2. 问题原因

- 后端使用 sharp 库将SVG转PNG
- sharp 依赖系统字体
- Manus服务器上没有安装中文字体

### 3. 尝试方案

**方案1**：安装中文字体到服务器
- 需要root权限，Manus不支持
- ❌ 放弃

**方案2**：在SVG中嵌入字体
- 需要将字体文件转为base64嵌入SVG
- 字体文件太大，SVG会很臃肿
- ❌ 放弃

### 4. 最终方案：前端Canvas渲染

AI生成SVG → 返回前端 → Canvas渲染 → 导出PNG → 上传Google Drive

**实现要点**：
- 后端返回SVG字符串给前端
- 前端用Canvas渲染SVG（Canvas可以使用浏览器的字体）
- 渲染完成后导出为PNG
- 再上传到Google Drive

**教训**：服务端字体问题可以用前端Canvas渲染绕过。

---

## 十一、SSE端到端改造（V45系列）

### 1. 背景：Cloudflare 524超时

**问题发现**：小班课7个学生学情反馈生成时
- AI生成耗时：142秒
- Cloudflare超时限制：100秒
- 结果：524 Timeout Error

**问题分析**：
- V22实现的流式输出是：后端到AI流式，但后端到前端仍是普通HTTP
- 后端必须等AI全部生成完，再一次性返回给前端
- 当AI生成超过100秒时，Cloudflare强制断开连接

### 2. SSE响应头设置

```typescript
res.setHeader('Content-Type', 'text/event-stream');
res.setHeader('Cache-Control', 'no-cache');
res.setHeader('Connection', 'keep-alive');
res.setHeader('X-Accel-Buffering', 'no');  // 关键：禁用Nginx缓冲
```

### 3. SSE事件格式设计

```
event: start
data: {"message":"开始生成","students":7}

event: progress
data: {"chars":1500}

event: complete
data: {"success":true,"feedback":"内容...","chars":13335}

event: error
data: {"message":"错误信息"}
```

### 4. 踩坑记录

**坑1：事件类型误判（V45b）**

**问题**：start事件被误判为error事件，导致生成立即失败。

**错误代码**：用字段判断事件类型
```typescript
// ❌ 错误做法
if (data.message && !data.feedback && !data.chars) {
  sseError = data.message;  // start事件也满足这个条件！
}
```

**分析**：
- start事件：`{"message":"开始为...", "students":6}`
- 有message ✓，没feedback ✓，没chars ✓
- 被错误地当成error事件

**正确代码**：用event:行判断事件类型
```typescript
// ✅ 正确做法
if (currentEventType === 'error' && data.message) {
  sseError = data.message;
} else if (currentEventType === 'start') {
  console.log('[SSE] 收到开始事件:', data.message);
}
```

**坑2：变量作用域导致状态丢失（V45b）**

**问题**：修复坑1后，complete事件的内容丢失。

日志显示：
```
[SSE] 收到完成事件，内容长度: 13739 字符
[DEBUG] SSE循环结束，feedbackContent长度: 0  // 为什么是0？
```

**错误代码**：`currentEventType`在for循环内部声明
```typescript
// ❌ 错误做法
while (true) {
  for (const line of lines) {
    let currentEventType = '';  // 每次循环都重置！
    if (line.startsWith('event: ')) {
      currentEventType = line.slice(7).trim();
    }
  }
}
```

**问题分析**：SSE的event:和data:行可能在不同数据块
- 数据块143: `"event: complete\n"` → currentEventType = 'complete'
- 数据块144: `"data: {...}\n"` → 新循环，currentEventType被重置为''

**正确代码**：在while循环外部声明
```typescript
// ✅ 正确做法
let currentEventType = '';  // 在while外部声明
while (true) {
  for (const line of lines) {
    if (line.startsWith('event: ')) {
      currentEventType = line.slice(7).trim();
    }
  }
}
```

**坑3：超长内容分块发送（V45l）**

**问题**：某次一对一生成失败
- 后端日志显示24971字符生成成功
- Google Drive有文件，内容正常
- 但前端报错："学情反馈生成失败: 未收到内容"

**对比测试**：
- 20982字符：成功
- 24971字符：失败

**问题定位**：内容超长时，complete事件的JSON数据太大，导致解析问题。

**解决方案**：分块发送

**后端代码**：
```typescript
const CHUNK_THRESHOLD = 15000;
const CHUNK_SIZE = 10000;

if (content.length > CHUNK_THRESHOLD) {
  // 分块发送
  const chunks = [];
  for (let i = 0; i < content.length; i += CHUNK_SIZE) {
    chunks.push(content.slice(i, i + CHUNK_SIZE));
  }

  chunks.forEach((chunk, index) => {
    sendEvent("content-chunk", {
      index,
      total: chunks.length,
      text: chunk
    });
  });

  sendEvent("complete", {
    success: true,
    chunked: true,  // 标记已分块
    chars: content.length,
    uploadResult: ...
  });
} else {
  // 小内容直接发
  sendEvent("complete", {
    success: true,
    feedback: content,
    chars: content.length,
    uploadResult: ...
  });
}
```

**前端代码**：
```typescript
let contentChunks: string[] = [];

if (currentEventType === 'content-chunk') {
  contentChunks[data.index] = data.text;
} else if (currentEventType === 'complete') {
  if (data.chunked) {
    feedbackContent = contentChunks.join('');
  } else {
    feedbackContent = data.feedback;
  }
}
```

### 5. SSE端点汇总

| 端点 | 功能 | 文件位置 |
|------|------|---------|
| `POST /api/feedback-stream` | 一对一学情反馈 | `server/classStreamRoutes.ts` |
| `POST /api/review-stream` | 一对一复习文档 | `server/classStreamRoutes.ts` |
| `POST /api/class-feedback-stream` | 小班课学情反馈 | `server/classStreamRoutes.ts` |
| `POST /api/class-review-stream` | 小班课复习文档 | `server/classStreamRoutes.ts` |

### 6. max_tokens配置

V45c将max_tokens从16000改为32000。

**修改原因**：14947字符 ≈ 10000-15000 token，接近16000上限，可能被截断。

**修改范围**：全部18处
- feedbackGenerator.ts: 6处
- routers.ts: 6处
- whatai.ts: 4处
- classStreamRoutes.ts: 2处

**验证命令**：`grep -r "16000" server/` 返回空，确认全部改完。

### 7. 日志系统补充（V45i-V45j）

**问题**：SSE改造后，生成成功但点击"导出日志"显示"没有找到日志文件"。

**原因**：SSE端点里没有调用日志系统函数。

**解决**：给4个SSE端点都添加日志记录逻辑。

### 8. 星期显示修复（V45f）

**问题**：生成的作业布置里星期显示错误

| 日期 | AI生成 | 实际 |
|------|--------|------|
| 2026年1月11日 | 周六 | 周日 |

**原因**：传给AI的日期没有附带星期，AI自己计算，算错了。

**解决**：新增 `addWeekdayToDate()` 工具函数
```typescript
function addWeekdayToDate(dateStr: string): string {
  const weekdays = ['日', '一', '二', '三', '四', '五', '六'];
  const date = new Date(dateStr);
  const weekday = weekdays[date.getDay()];
  return `${dateStr}（周${weekday}）`;
}
```

**修改后传给AI的日期格式**：
- 之前：`2026年1月11日`
- 之后：`2026年1月11日（周日）`

**教训**：不要让AI自己计算能算出来的东西，直接告诉它。

---

## 十二、代码架构问题（技术债）

### 1. 代码重复问题

`classStreamRoutes.ts` 里重新定义了：
- `DEFAULT_CONFIG`
- `getConfig()` 函数
- `CLASS_FEEDBACK_SYSTEM_PROMPT`

这些在 `routers.ts` 里也有定义，导致：
- 代码冗余
- 改一边忘记改另一边就会出问题

**建议**：应该把公共代码提取到单独模块复用。

### 2. 没有模块化的后果

每次修复都要改多处：
- 事件类型判断的bug：需要改4个SSE端点
- 日志记录的bug：需要改4个SSE端点
- max_tokens配置：需要改18处

**教训**：没有模块化导致同样的修复要做多遍，技术债累积严重。

---

## 十三、性能数据汇总

| 场景 | 耗时 | 字符数 | 状态 |
|------|------|--------|------|
| 小班课7学生学情反馈 | 176秒 | 14915 | ✅ 不超时 |
| 一对一学情反馈 | 131-194秒 | 20000-25000 | ✅ 不超时 |
| 一对一复习文档 | 107-262秒 | 22000-26000 | ✅ 不超时 |
| 超长内容（分块） | - | 24226 | ✅ 正常解析 |

---

## 十四、关键教训总结（V29-V45）

| 版本 | 教训 |
|------|------|
| V33 | 项目一开始就应该用版本控制，不要等出问题再补 |
| V35 | 代码改完要发布，不发布只在沙盒运行 |
| V39-40 | 并发场景下不能用全局变量存储请求相关的状态 |
| V42 | 服务端字体问题可以用前端Canvas渲染绕过 |
| V44 | 超过100秒的请求会被Cloudflare强制断开 |
| V45b | SSE事件类型要用event:行判断，不要用字段判断 |
| V45b | 关键状态变量要在循环外部声明，避免跨数据块丢失 |
| V45c | max_tokens要根据实际输出长度设置，留足余量 |
| V45f | 不要让AI自己计算能算出来的东西，直接告诉它 |
| V45i-j | 改造代码时要检查关联功能是否受影响 |
| V45l | 超长JSON数据可能导致解析失败，需要分块发送 |
| 通用 | 没有模块化导致每个端点都要改一遍，技术债累积严重 |

---

## 十五、SSE实现自检清单

改造或新增SSE端点时，必须检查以下项目：

| 检查项 | 位置 | 确认 |
|--------|------|------|
| 响应头设置正确（Content-Type、X-Accel-Buffering） | 后端SSE端点 | □ |
| 事件类型判断用 currentEventType | 前端SSE解析 | □ |
| currentEventType 在 while 外部声明 | 前端SSE解析 | □ |
| complete事件正确赋值内容 | 前端SSE解析 | □ |
| 超长内容分块发送 | 后端SSE端点 | □ |
| max_tokens = 32000 | 后端SSE端点 | □ |
| 上传后返回 uploadResult | 后端SSE端点 | □ |
| 日志记录已添加 | 后端SSE端点 | □ |
| 一对一功能不受影响 | 测试 | □ |
| 小班课功能不受影响 | 测试 | □ |

---

## 十六、批量处理模块（V46）

### 1. 功能概述

批量处理允许用户一次性生成多个独立任务（如50个词汇List各生成一份Word文档）。

**核心特性**：
- 任务编号范围配置（如1-50）
- 并发池模式执行
- 实时进度显示
- 自动上传Google Drive

### 2. 并发池工作机制

**设计思路**：不是等所有任务排队执行，而是维护一个固定大小的"执行池"。

```
并发数设置: 5
总任务: 12

时间线:
t0:  [1] [2] [3] [4] [5]  ← 5个槽位全满
t1:  [1] [6] [3] [4] [5]  ← 任务2完成，任务6立即顶上
t2:  [1] [6] [7] [4] [5]  ← 任务3完成，任务7立即顶上
...
t10: [ ] [ ] [ ] [ ] [ ]  ← 全部完成
```

**核心实现**（`server/core/concurrencyPool.ts`）：
```typescript
export class ConcurrencyPool {
  private running = 0;
  private queue: Task[] = [];
  private concurrency: number;

  constructor(concurrency: number) {
    this.concurrency = concurrency;
  }

  async add(task: () => Promise<void>): Promise<void> {
    if (this.running >= this.concurrency) {
      // 池子满了，等待空位
      await new Promise<void>(resolve => {
        this.queue.push({ execute: task, resolve });
      });
    } else {
      // 有空位，直接执行
      this.running++;
      try {
        await task();
      } finally {
        this.running--;
        this.tryNext();
      }
    }
  }

  private tryNext() {
    if (this.queue.length > 0 && this.running < this.concurrency) {
      const next = this.queue.shift()!;
      this.running++;
      next.execute()
        .finally(() => {
          this.running--;
          next.resolve();
          this.tryNext();
        });
    }
  }
}
```

**使用方式**：
```typescript
const pool = new ConcurrencyPool(5);

for (const task of tasks) {
  pool.add(async () => {
    await generateDocument(task);
    sendProgress(task.id, 'complete');
  });
}
```

### 3. SSE公共模块抽取

**问题**：V45有4个SSE端点，每个端点都有大量重复代码（响应头设置、事件发送、错误处理）。

**解决**：抽取公共函数到 `server/core/sseHelper.ts`。

**核心函数**：
```typescript
// 初始化SSE连接
export function initSSE(res: Response) {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('X-Accel-Buffering', 'no');
}

// 发送SSE事件
export function sendSSEEvent(res: Response, event: string, data: any) {
  res.write(`event: ${event}\n`);
  res.write(`data: ${JSON.stringify(data)}\n\n`);
}

// 发送分块内容（超长内容处理）
export function sendChunkedContent(
  res: Response,
  content: string,
  threshold = 15000,
  chunkSize = 10000
) {
  if (content.length > threshold) {
    const chunks = [];
    for (let i = 0; i < content.length; i += chunkSize) {
      chunks.push(content.slice(i, i + chunkSize));
    }
    chunks.forEach((chunk, index) => {
      sendSSEEvent(res, 'content-chunk', {
        index,
        total: chunks.length,
        text: chunk
      });
    });
    return true; // 已分块
  }
  return false; // 未分块，调用者自行发送
}
```

**改造效果**：
- 4个原有SSE端点代码量减少约40%
- 新增批量处理端点可复用公共函数
- 一处修改，处处生效

### 4. Word文档生成模块

**文件位置**：`server/core/wordGenerator.ts`

**核心函数**：
```typescript
import { Document, Packer, Paragraph, TextRun } from 'docx';

export async function generateWordDoc(content: string): Promise<Buffer> {
  // 将Markdown转换为Word段落
  const paragraphs = content.split('\n').map(line => {
    if (line.startsWith('# ')) {
      return new Paragraph({
        children: [new TextRun({ text: line.slice(2), bold: true, size: 32 })],
      });
    }
    // ... 其他格式处理
    return new Paragraph({ children: [new TextRun(line)] });
  });

  const doc = new Document({
    sections: [{ children: paragraphs }],
  });

  return await Packer.toBuffer(doc);
}
```

### 5. 批量处理SSE端点

**端点**：`POST /api/batch-stream`

**请求参数**：
```json
{
  "startNum": "number",
  "endNum": "number",
  "concurrency": "number",
  "roadmap": "string",
  "storagePath": "string",
  "templateType": "string ('general' | 'wordCard')"
}
```

**SSE事件类型**：

| 事件 | 数据 | 说明 |
|------|------|------|
| start | `{total: number}` | 开始执行 |
| task-start | `{taskId: number}` | 单个任务开始 |
| task-progress | `{taskId: number, chars: number}` | 任务进度更新 |
| task-complete | `{taskId: number, success: boolean, url?: string}` | 任务完成 |
| complete | `{success: boolean, completed: number, failed: number}` | 全部完成 |
| error | `{message: string}` | 错误信息 |

### 6. 踩坑记录

**坑1：文件名混乱**

**问题**：批量处理生成的文件名显示"学情反馈"。

**原因**：复用了课堂反馈的命名函数。

**解决**：批量处理使用独立的命名逻辑。
```typescript
// ❌ 错误做法 - 复用课堂反馈命名
const fileName = `${studentName}${date}学情反馈.docx`;

// ✅ 正确做法 - 独立命名
const fileName = `任务${String(taskId).padStart(2, '0')}_${taskTitle}.docx`;
```

**坑2：并发数限制不生效**

**问题**：设置并发数5，但实际同时执行了全部任务。

**原因**：并发池的 add 方法没有正确等待。

**解决**：修复 Promise 等待逻辑。

---

## 十七、模板系统（V47）

### 1. 设计背景

**问题**：V46的通用文档模式只能生成简单格式的Word，无法实现精确排版（如紫色主题、双栏卡片布局）。

**分析**：
- Markdown转Word：格式有限，无法精确控制
- AI直接生成Word：不可行，AI只能输出文本
- 解决方案：AI输出结构化数据（JSON），程序套用代码模板生成Word

### 2. 两种模板的区别

| 模板 | AI输出 | 程序处理 | 适用场景 |
|------|--------|---------|---------|
| 通用文档 | Markdown文本 | 简单格式转换 | 一般文档 |
| 词汇卡片 | JSON数据 | 套用代码模板 | 精确排版 |

### 3. 词汇卡片JSON格式

AI必须按以下格式输出：
```json
{
  "listNumber": 3,
  "sceneName": "Library",
  "wordCount": 25,
  "words": [
    {
      "num": 65,
      "word": "Librarian",
      "phonetic": "/laɪˈbreəriən/",
      "pos": "n.",
      "meaning": "图书管理员",
      "example": "The librarian helped me find reference books.",
      "translation": "图书管理员帮我找到了参考书。"
    }
  ]
}
```

### 4. 代码模板实现

**文件位置**：`server/templates/wordCardTemplate.ts`（约280行）

**结构**：
```typescript
// 1. 类型定义
interface WordEntry {
  num: number;
  word: string;
  phonetic: string;
  pos: string;
  meaning: string;
  example: string;
  translation: string;
}

interface WordListData {
  listNumber: number;
  sceneName: string;
  wordCount: number;
  words: WordEntry[];
}

// 2. 格式常量
const SPEC = {
  colors: {
    primary: '7C3AED',      // 紫色主题
    background: 'F3E8FF',   // 浅紫背景
    border: 'DDD6FE',       // 边框色
  },
  fonts: {
    title: 28,
    word: 24,
    body: 20,
  },
  spacing: {
    cardGap: 200,
    padding: 150,
  },
};

// 3. 组件函数
function createCard(word: WordEntry): TableRow { ... }
function createTitleBar(data: WordListData): Paragraph { ... }
function createWordGrid(words: WordEntry[]): Table { ... }

// 4. 主函数
export async function generateWordListDocx(data: WordListData): Promise<Buffer> {
  const doc = new Document({
    sections: [{
      children: [
        createTitleBar(data),
        createWordGrid(data.words),
      ],
    }],
  });
  return await Packer.toBuffer(doc);
}
```

### 5. 路书要求

让AI输出JSON时，必须在路书中明确：
```
【输出格式要求】
1. 只输出纯JSON，不要输出任何其他内容
2. 不要输出Markdown代码块标记（如```json）
3. 不要输出任何解释或说明
4. 确保JSON格式正确，可直接被JSON.parse()解析
```

### 6. 踩坑记录

**坑1：JSON解析失败**

**问题**：AI输出的JSON无法解析。

**原因**：AI输出了Markdown代码块标记。

**解决**：
1. 路书明确禁止Markdown标记
2. 后端添加清理逻辑作为兜底

```typescript
function cleanJsonOutput(text: string): string {
  // 去除可能的Markdown代码块标记
  return text
    .replace(/^```json\s*/i, '')
    .replace(/^```\s*/i, '')
    .replace(/\s*```$/i, '')
    .trim();
}
```

**坑2：模块语法错误**

**问题**：词汇卡片模板文件语法错误。

**原因**：混用了CommonJS和ES Module语法。
```typescript
// ❌ 错误做法
const { Document } = require('docx');
module.exports = { generateWordListDocx };

// ✅ 正确做法
import { Document } from 'docx';
export { generateWordListDocx };
```

**教训**：TypeScript项目统一使用 import/export 语法。

---

## 十八、V46-V47关键教训总结

| 版本 | 教训 |
|------|------|
| V46 | 新功能使用独立的命名和逻辑，不要复用其他功能导致混乱 |
| V46 | 大项目要拆成里程碑，找到"最小可用版本"节点 |
| V46 | 公共代码要抽取成模块，避免每个端点都要改一遍 |
| V47 | 让AI输出JSON时，必须明确禁止Markdown标记 |
| V47 | 精确排版需求用专门的代码模板，不要强求通用方案 |
| V47 | TypeScript项目统一使用import/export语法 |
| 通用 | 技术确认先行，开始新功能前先确认技术细节 |

---

## 十九、批量处理自检清单

新增或修改批量处理功能时，必须检查以下项目：

| 检查项 | 位置 | 确认 |
|--------|------|------|
| 并发池初始化正确 | 后端batch-stream | □ |
| 任务进度事件发送 | 后端batch-stream | □ |
| 文件命名独立（不复用其他功能） | wordGenerator | □ |
| Google Drive链接返回 | 后端batch-stream | □ |
| 并发数限制生效 | concurrencyPool | □ |
| JSON输出清理（去除Markdown标记） | 后端batch-stream | □ |
| 模板类型分支正确 | 后端batch-stream | □ |
| 前端进度显示正确 | BatchProcess.tsx | □ |
| 错误处理完善 | 前后端 | □ |

---

## 二十、V48 批量处理功能增强

### 1. Markdown解析器完善

**背景**：V46的Word生成器只支持标题和普通段落，无法处理表格、列表等复杂格式。

**V48新增支持**：
- 粗体/斜体：`**文本**` → Word粗体，`*文本*` → Word斜体
- 表格：Markdown表格 → Word表格（带样式有背景色）
- 列表：有序/无序列表 → Word列表
- 引用块：`> 内容` → 缩进段落（带样式有橙色标记）
- 分隔线：`---` → Word分隔线

**核心实现**（`batchWordGenerator.ts`）：
```typescript
// 粗体/斜体解析
function parseInlineFormatting(text: string): TextRun[] {
  // 使用正则匹配 **粗体** *斜体* ***粗斜体***
  // 返回带对应bold/italics属性的TextRun数组
}

// 表格解析
function parseMarkdownTable(lines: string[], startIndex: number): { table: Table, endIndex: number } {
  // 识别|开头的连续行
  // 第1行表头，第2行分隔符跳过，后续行数据
  // 返回docx的Table对象
}
```

**样式配置**：

| 元素 | 带样式模式 | 无样式模式 |
|------|-----------|-----------|
| 标题 | #6A1B9A（紫色） | 黑色 |
| 表头背景 | #E8D5F0（浅紫） | 无 |
| 引用标记 | #FF6F00（橙色） | 无 |

### 2. 文件上传功能

**设计思路**：
- 图片：直接转Base64，用image_url方式传给AI（同步处理）
- 文档：上传到S3获取URL，用file_url方式传给AI（需网络访问）

**上传接口**：`POST /api/batch/upload-files`

```typescript
// 请求：multipart/form-data，字段名files
// 响应：
interface UploadResponse {
  success: boolean;
  files: Array<{
    originalName: string;
    mimeType: string;
    size: number;
    type: 'document' | 'image';
    url?: string;           // 文档才有
    base64DataUri?: string; // 图片才有
  }>;
  summary: { total: number; success: number; error: number; };
}
```

**文件大小限制**：
- 文档：30MB
- 图片：20MB

**支持的文件类型**：
- 文档：.pdf, .docx, .txt, .md
- 图片：.png, .jpg, .jpeg, .webp

### 3. llm.ts增强

V48改动：扩展invokeAIStream函数，支持文件参数

```typescript
// 新增FileInfo类型
export interface FileInfo {
  type: 'document' | 'image';
  url?: string;
  base64DataUri?: string;
  mimeType: string;
}

// 修改invokeAIStream签名
export async function invokeAIStream(
  messages: Message[],
  options?: Options,
  config?: APIConfig,
  onChunk?: (chunk: string) => void,
  fileInfo?: FileInfo  // V48新增
): Promise<string>
```

**消息构建逻辑**：
```typescript
const content: any[] = [];

// 如果有文件，先添加文件
if (fileInfo) {
  if (fileInfo.type === 'image' && fileInfo.base64DataUri) {
    content.push({
      type: "image_url",
      image_url: { url: fileInfo.base64DataUri, detail: "high" }
    });
  } else if (fileInfo.type === 'document' && fileInfo.url) {
    content.push({
      type: "file_url",
      file_url: { url: fileInfo.url, mime_type: fileInfo.mimeType }
    });
  }
}

// 最后添加文本
content.push({ type: "text", text: prompt });
```

**MIME类型**：从限制性枚举改为string类型，支持所有文档类型。

### 4. 文件命名方式B

**功能**：用户可以输入多行文本，每行对应一个任务的文件名。

**前端状态**：
```typescript
const [namingMethod, setNamingMethod] = useState<'prefix' | 'text'>('prefix');
const [fileNameText, setFileNameText] = useState('');
const [customFileNames, setCustomFileNames] = useState<Map<number, string>>(new Map());
```

**解析规则**：
- 第1行 → 起始任务编号的文件名
- 空行 → 使用默认值「任务XX」
- 自动过滤非法字符：`\ / : * ? " < > |`

**后端接收**：
```typescript
interface BatchGenerateRequest {
  // ... 其他字段
  customFileNames?: Record<number, string>;  // V48新增
}
```

### 5. V48踩坑记录

**坑1：MIME类型过于严格**

**问题**：llm.ts的mime_type定义只支持几种固定类型，.docx和.md无法使用。

**解决**：将mime_type从枚举改为string类型。

**坑2：文件上传排序**

**问题**：多文件上传后，分配给任务的顺序不对。

**解决**：按文件名排序后再分配，使用中文排序规则localeCompare。

**坑3：base64DataUri字段名不一致**

**问题**：前端传base64DataUri，后端用base64Data，导致取不到值。

**解决**：统一字段名为base64DataUri。

---

## 二十一、V48自检清单

新增或修改批量处理功能时，必须检查：

| 检查项 | 位置 | 确认 |
|--------|------|------|
| Markdown解析器支持所有格式 | batchWordGenerator.ts | □ |
| 文件上传接口返回正确格式 | batchRoutes.ts | □ |
| 图片转Base64成功 | batchRoutes.ts | □ |
| 文档上传S3成功 | batchRoutes.ts | □ |
| llm.ts正确构建带文件的消息 | llm.ts | □ |
| 前端正确传递files参数 | BatchProcess.tsx | □ |
| 文件命名方式B正确解析 | 前后端 | □ |
| 表格样式正确（带样式/无样式） | batchWordGenerator.ts | □ |

---

## 二十二、V49 配置增强

### 1. 版本号显示实现

**目标**：在页面右上角显示当前版本号，方便确认运行版本。

**实现位置**：`client/src/pages/BatchProcess.tsx`

**实现方式**：
```tsx
// 版本号常量
const APP_VERSION = "V51";

// 在组件中显示
<div className="fixed top-2 right-4 text-xs text-gray-400">
  {APP_VERSION}
</div>
```

**注意事项**：
- 使用fixed定位，确保始终可见
- 使用小号灰色字体，不影响主要界面
- 每次版本发布时更新常量值

### 2. max_tokens可配置

**背景**：不同AI模型的token上限不同：
- GPT-4o: 16,384 tokens
- Claude 4.5 Sonnet: 64,000 tokens

**实现**：

1. **数据库配置**：在`system_config`表新增配置项
```sql
INSERT INTO system_config (key, value, description)
VALUES ('max_tokens', '64000', '最大输出token数');
```

2. **后端读取**：`batchRoutes.ts`
```typescript
const maxTokens = await getConfig('max_tokens') || '64000';
const maxTokensNum = parseInt(maxTokens, 10);
```

3. **前端配置界面**：高级设置区域新增输入框

**默认值变更**：32000 → 64000

### 3. 输出截断检测

**问题**：当AI输出超过max_tokens限制时，内容会被截断，但用户可能不知道。

**实现**：

1. **后端检测**：解析AI返回的`stop_reason`字段
```typescript
const response = await invokeAIStream(...);
// 如果stop_reason为"max_tokens"，表示输出被截断
if (response.stop_reason === 'max_tokens') {
  sendSSEEvent(res, 'warning', {
    message: '输出内容可能被截断，建议增大max_tokens配置'
  });
}
```

2. **前端提示**：收到warning事件时弹出提示
```typescript
if (eventType === 'warning') {
  toast.warning(data.message);
}
```

---

## 二十三、V50 模板格式说明

### 1. 模板说明数据结构

```typescript
const TEMPLATE_DESCRIPTIONS: Record<string, string> = {
  markdown_styled: `【教学材料（带样式）模板】
AI输出格式：Markdown文本
样式特点：
- 标题使用紫色(#6A1B9A)
- 表头有浅紫色背景(#E8D5F0)
- 引用块前有橙色标记(#FF6F00)
...`,

  markdown_plain: `【通用文档（无样式）模板】
AI输出格式：Markdown文本
样式特点：黑白简洁，无特殊颜色
...`,

  // ... 其他模板
};
```

### 2. 说明区域UI实现

```tsx
{/* 模板格式说明区域 */}
<div className="mt-2 p-3 bg-gray-50 rounded border text-sm">
  <div className="flex justify-between items-start mb-2">
    <span className="font-medium text-gray-700">模板格式说明</span>
    <button
      onClick={handleCopy}
      className="text-gray-500 hover:text-gray-700"
    >
      {copied ? <CheckIcon /> : <CopyIcon />}
    </button>
  </div>
  <div className="h-[120px] overflow-y-auto whitespace-pre-wrap text-gray-600">
    {TEMPLATE_DESCRIPTIONS[templateType]}
  </div>
</div>
```

### 3. 复制功能实现

```typescript
const [copied, setCopied] = useState(false);

const handleCopy = async () => {
  try {
    await navigator.clipboard.writeText(TEMPLATE_DESCRIPTIONS[templateType]);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  } catch (err) {
    console.error('复制失败:', err);
  }
};
```

### 4. 新增写作素材模板

**模板标识**：`writing_material`

**适用场景**：托福写作教学素材生成

**输出格式**：Markdown文本

---

## 二十四、V51 文档转文字

### 1. 功能概述

**问题背景**：
- 部分AI模型不支持直接处理file_url
- 直接传URL依赖AI端的文件访问能力
- 提取纯文本后传给AI兼容性更好

**解决方案**：
- 上传文档后在后端提取纯文本
- 将提取的文本作为消息内容发给AI
- 用XML标签区分不同来源的内容

### 2. 文档解析技术选型

| 文件类型 | 解析库 | 说明 |
|---------|--------|------|
| .docx | mammoth | 提取Word文档纯文本 |
| .pdf | pdf-parse | 提取PDF纯文本 |
| .txt | 直接读取 | fs.readFile |
| .md | 直接读取 | fs.readFile |

**实现代码**（`documentExtractor.ts`）：

```typescript
import mammoth from 'mammoth';
import pdfParse from 'pdf-parse';
import fs from 'fs/promises';

export async function extractText(filePath: string, mimeType: string): Promise<string> {
  if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
    // Word文档
    const result = await mammoth.extractRawText({ path: filePath });
    return result.value;
  } else if (mimeType === 'application/pdf') {
    // PDF文档
    const buffer = await fs.readFile(filePath);
    const result = await pdfParse(buffer);
    return result.text;
  } else {
    // 文本文件
    return await fs.readFile(filePath, 'utf-8');
  }
}
```

### 3. XML来源标签设计

**目的**：帮助AI理解不同内容的来源和用途

**三种标签**：

```xml
<路书提示词>
用户定义的项目总体路书，包含任务指令和输出要求。
</路书提示词>

<共享文档>
所有任务共享的参考文档内容，如词汇总表、模板范例等。
</共享文档>

<单独文档>
当前任务独有的配套文档内容，如特定题目图片的OCR文本。
</单独文档>
```

**消息构建示例**：

```typescript
function buildMessageContent(
  roadmap: string,
  sharedDocs: string[],
  independentDoc?: string
): string {
  let content = '';

  // 路书提示词
  content += `<路书提示词>\n${roadmap}\n</路书提示词>\n\n`;

  // 共享文档
  if (sharedDocs.length > 0) {
    content += `<共享文档>\n`;
    sharedDocs.forEach((doc, i) => {
      content += `[共享文档${i + 1}]\n${doc}\n\n`;
    });
    content += `</共享文档>\n\n`;
  }

  // 单独文档
  if (independentDoc) {
    content += `<单独文档>\n${independentDoc}\n</单独文档>\n`;
  }

  return content;
}
```

### 4. 前后端数据传递修复

**问题**：前端上传文件后提取的文本没有传递到后端

**原因**：BatchProcess.tsx中的文件映射逻辑遗漏了extractedText字段

**修复代码**：

```typescript
// 修复前（错误）
const fileMapping = uploadedFiles.map(f => ({
  name: f.name,
  url: f.url,
  mimeType: f.mimeType,
}));

// 修复后（正确）
const fileMapping = uploadedFiles.map(f => ({
  name: f.name,
  url: f.url,
  mimeType: f.mimeType,
  extractedText: f.extractedText, // 添加这个字段
}));
```

---

## 二十五、V49-V51 踩坑记录

### 1. Git Rebase覆盖改动

**问题现象**：
- V49版本号位置从右上角变回右下角
- 明明已commit的改动消失了

**原因分析**：
- Manus保存Checkpoint时可能执行git rebase
- 冲突自动解决时选择了旧版本的代码

**预防措施**：
1. Checkpoint后验证提交历史：`git log --oneline -5`
2. 发布后用无痕模式访问正式环境验证
3. 关键改动及时push到GitHub

### 2. 前端字段传递遗漏

**问题现象**：
- 后端收到的文件信息中没有extractedText
- AI收到的是文件URL而不是提取的文本

**排查方法**：
```typescript
// 在后端添加调试日志
console.log('收到的文件信息:', JSON.stringify(files, null, 2));
```

**经验教训**：
- 新增字段时要检查整个数据流
- 前端state → API请求 → 后端处理 → AI调用

### 3. 依赖库安装问题

**问题**：pdf-parse或mammoth库未安装导致运行时错误

**解决**：
```bash
pnpm add mammoth pdf-parse
pnpm add -D @types/pdf-parse
```

---

## 二十六、V49-V51 自检清单

### V49功能验收

- [ ] 版本号显示在页面右上角
- [ ] 高级设置可配置max_tokens
- [ ] max_tokens默认值为64000
- [ ] 输出截断时有警告提示

### V50功能验收

- [ ] 选择模板后显示格式说明
- [ ] 说明区域固定120px高度可滚动
- [ ] 复制按钮功能正常
- [ ] 复制成功显示绿色对勾
- [ ] 写作素材模板可选

### V51功能验收

- [ ] 上传Word文档能提取文本
- [ ] 上传PDF文档能提取文本
- [ ] 提取的文本正确传递给AI
- [ ] XML标签正确包裹各部分内容
- [ ] 共享文档和独立文档都能正确处理

---

## 二十七、AI代码生成系统（V52）

### 1. 沙箱执行架构

**核心流程**：
```
用户路书 → AI 生成代码 → 沙箱执行 → 成功？
                                    ↓
                          否 → 格式化错误 → AI 修正 → 重试（最多3次）
                          ↓
                          是 → 验证文件 → 上传
```

**沙箱技术选型**：使用 vm2 的 NodeVM
```typescript
import { NodeVM } from 'vm2';

const vm = new NodeVM({
  timeout: 30000,
  sandbox: {
    docx: require('docx'),  // 预注入 docx 模块
    console: console,
    Buffer: Buffer
  },
  require: {
    external: false,  // 禁止外部模块
    builtin: ['fs', 'path'],  // 只允许这些内置模块
    root: outputDir,  // 限制文件访问目录
  }
});
```

**安全限制**：
- 模块白名单：只允许 docx, fs, path
- 目录限制：只能写入指定输出目录
- 超时保护：30 秒执行超时
- 禁止网络访问

### 2. 错误格式化

**错误信息结构**：
```typescript
interface FormattedError {
  type: string;       // 错误类型（SyntaxError, TypeError 等）
  message: string;    // 错误信息
  line?: number;      // 错误行号
  column?: number;    // 错误列号
  codeSnippet?: string;  // 错误位置前后的代码片段
}
```

**反馈给 AI 的格式**：
```
【第1次尝试失败】

错误类型：SyntaxError
错误信息：Unexpected token '}'
错误位置：第47行，第5列

出错代码（第42-52行）：
42:     children: [
43:       new Paragraph({
...
47:     }  // ← 错误在这里

请修正这个错误，重新输出完整代码。
```

### 3. 踩坑记录

**坑1：vm2 中 require 不可用**

**问题**：在 vm2 沙箱中 `require('docx')` 抛出错误

**原因**：vm2 默认禁止 require

**解决**：
- 方案A：使用 NodeVM 并配置 require 选项
- 方案B：将 docx 模块预先注入到 sandbox 中

**坑2：ESM 和 CommonJS 混用**

**问题**：AI 生成的代码使用 import，但沙箱期望 require

**解决**：在 AI 提示词中明确要求使用 CommonJS 风格，或在执行前转换代码

---

## 二十八、SSE 稳定性优化（V64）

### 1. 心跳机制

**问题**：长时间无事件时，代理/网关会断开连接

**解决**：每 15 秒发送心跳事件
```typescript
// 后端
const heartbeatInterval = setInterval(() => {
  res.write(`event: heartbeat\ndata: ${Date.now()}\n\n`);
}, 15000);

// 清理
res.on('close', () => clearInterval(heartbeatInterval));
```

```typescript
// 前端处理
if (eventType === 'heartbeat') {
  lastHeartbeat = Date.now();
  return; // 心跳不需要更新 UI
}
```

### 2. 断线降级机制

**问题**：连接断开后，任务可能已经完成但用户不知道

**解决**：先查询状态再决定是否报错
```typescript
// 前端 SSE 断开后
try {
  const status = await fetch(`/api/batch/status/${batchId}`);
  const data = await status.json();

  if (data.status === 'completed') {
    // 任务已完成，恢复状态
    restoreFromStatus(data);
  } else if (data.status === 'running') {
    // 任务还在跑，重新连接或轮询
    startPolling(batchId);
  } else {
    // 真的失败了
    showError(data.error);
  }
} catch (e) {
  showError('连接断开，请刷新页面');
}
```

### 3. 状态查询接口

```typescript
// GET /api/batch/status/:batchId
app.get('/api/batch/status/:batchId', async (req, res) => {
  const { batchId } = req.params;
  const status = batchStatusMap.get(batchId);

  if (!status) {
    return res.status(404).json({ error: '批次不存在' });
  }

  res.json({
    batchId,
    status: status.status,  // 'running' | 'completed' | 'failed'
    tasks: status.tasks,
    completedCount: status.completedCount,
    totalCount: status.totalCount,
  });
});
```

---

## 二十九、批量处理指定任务（V65）

### 1. 前端实现

**新增状态**：
```typescript
const [taskMode, setTaskMode] = useState<'range' | 'specific'>('range');
const [specificTasks, setSpecificTasks] = useState("");
```

**解析函数**：
```typescript
const parseSpecificTasks = (input: string): number[] => {
  return input
    .split(',')
    .map(s => s.trim())
    .filter(s => s !== '')
    .map(s => parseInt(s, 10))
    .filter(n => !isNaN(n) && n > 0);
}
```

**提交逻辑**：
```typescript
if (taskMode === 'range') {
  body = { startNumber, endNumber, ... };
} else {
  const taskNumbers = parseSpecificTasks(specificTasks);
  body = { taskNumbers, ... };
}
```

### 2. 后端实现

**参数接收**：
```typescript
const { startNumber, endNumber, taskNumbers: inputTaskNumbers, ... } = req.body;

let taskNumbers: number[];
if (inputTaskNumbers && Array.isArray(inputTaskNumbers) && inputTaskNumbers.length > 0) {
  // 指定任务模式
  taskNumbers = inputTaskNumbers.filter((n: unknown) => typeof n === 'number' && n > 0);
} else {
  // 连续范围模式
  taskNumbers = [];
  for (let i = startNumber; i <= endNumber; i++) {
    taskNumbers.push(i);
  }
}
```

### 3. 踩坑记录

**坑：变量作用域问题**

**问题**：将 start 和 end 变量定义移到 else 分支内后，服务器崩溃

**原因**：有两处代码在分支外引用这些变量
- 第 245 行：`console.log(`任务范围: ${start} - ${end}`)`
- 第 289-290 行：`sendEvent('start', { startNumber: start, endNumber: end })`

**解决**：
```typescript
// 使用 taskNumbers 数组的首尾元素
const firstTask = taskNumbers[0];
const lastTask = taskNumbers[taskNumbers.length - 1];
console.log(`任务范围: ${firstTask} - ${lastTask} (共 ${taskNumbers.length} 个)`);
```

**教训**：修改变量作用域时，必须全局搜索该变量的所有引用位置。

---

## 三十、V52-V65 自检清单

### AI代码生成功能验收

- [ ] AI 能正确生成 docx-js 代码
- [ ] 沙箱能安全执行代码
- [ ] 错误能正确捕获并格式化
- [ ] AI 能根据错误信息修正代码
- [ ] 最多重试 3 次
- [ ] 生成的 docx 文件结构完整

### SSE 稳定性验收

- [ ] 心跳事件每 15 秒发送
- [ ] 前端能正确处理心跳
- [ ] 连接断开后能查询状态
- [ ] 降级机制正常工作

### 指定任务功能验收

- [ ] 连续范围模式正常
- [ ] 指定任务模式正常（如 1,3,5）
- [ ] 文件命名正确（保留原编号）
- [ ] 跳过的编号不生成文件

---

## 三十一、V68-V71 SSE传输稳定性

### 1. SSE分块传输丢失（V68）

**问题**：SSE传输大内容时，部分数据在传输过程中丢失，前端收到的内容不完整。

**排查过程**：
- CHUNK_SIZE 从 15000 增大到 50000（V68）
- 添加 `res.flush()` 强制刷新缓冲区（V68.2）
- 使用填充数据强制刷新（V68.3）
- 以上方案均不彻底

**教训**：SSE 本质上不适合传输大量数据，它更适合传事件通知。

### 2. res.flush() 兼容性问题（V68.2）

**问题**：V68.2 添加的 `res.flush()` 调用在 compression 中间件未启用时会报错，因为 flush 方法是 compression 中间件添加的。

**教训**：调用任何方法前要确认方法是否存在，尤其是中间件注入的方法。

**通用建议**：使用可选链 `res.flush?.()` 或先检查 `typeof res.flush === 'function'`。

### 3. 内存暂存 + HTTP拉取方案（V71）

**问题**：SSE传大数据不可靠，但前端需要实时知道生成进度。

**最终方案**：
- SSE 只传事件通知（如 `{type: 'complete', taskId: 'xxx'}`）
- 大内容存在服务端内存（contentStore）中
- 前端收到通知后，通过独立 HTTP GET 接口拉取完整内容
- contentStore 设置 500 条上限，防止内存溢出

**代码模式**：
```typescript
// 服务端：存入内存
contentStore.set(taskId, largeContent);
// SSE：只传通知
sendEvent('complete', { taskId });
// 前端：HTTP拉取
const content = await fetch(`/api/content/${taskId}`);
```

**教训**：职责分离——SSE负责通知，HTTP负责数据传输。

---

## 三十二、V72-V100 AI输出质量与健壮性

### 1. AI元评论问题

**问题**：AI在输出正文之前或之后经常添加"元评论"，如"以下是我为您生成的反馈文档："、"希望以上内容对您有帮助"等。这些内容直接出现在交给学生或家长的文档中。

**解决方案**：
- 新增 `stripAIMetaCommentary` 函数，使用正则统一剔除
- 在 `compressTranscript` 中也添加禁止元评论的指令
- prompt 中明确要求"直接输出内容，不要添加任何前言或总结"

**教训**：不要依赖prompt约束AI行为，必须有后处理兜底。

### 2. OAuth token刷新并发锁

**问题**：多个并发请求同时发现 token 过期，都去刷新 token，导致 Google API 返回错误。

**解决方案**：
```typescript
let refreshPromise = null;
async function refreshToken() {
  if (refreshPromise) return refreshPromise; // 复用进行中的刷新
  refreshPromise = doRefresh().finally(() => { refreshPromise = null; });
  return refreshPromise;
}
```

**教训**：并发场景下，幂等操作（如 token 刷新）应使用"单次执行 + 结果共享"模式。

### 3. DebouncedTextarea 防抖组件

**问题**：大段文字（如录音转文字 2万字）输入到 textarea 时，每次 onChange 触发 React 重渲染，导致界面严重卡顿。

**解决方案**：自定义 DebouncedTextarea 组件，输入过程中使用本地 state，停止输入 300ms 后才同步到父组件 state。

**教训**：React 受控组件在大数据量时性能很差，必须做防抖优化。

### 4. AI代码生成模式移除

**背景**：V52辛苦实现的 AI 代码生成系统（AI 写 docx-js 代码 → 沙箱执行 → Word 文件）在实际使用中发现：
- AI 生成的代码经常有语法错误（尤其是中文标识符未加引号）
- 沙箱执行环境限制多（ESM/require 兼容、字体问题等）
- 重试3次后成功率仍不够高

**决策**：V72-V100 期间移除了 ai_code 模式。

**教训**：功能开发前要先验证实际需求和可行性。"技术上能实现"不等于"实际场景中好用"。

---

## 三十三、V103-V111 Google Drive深度集成

### 1. 自动提取方案（V105-V106）

**功能**：系统自动从 Google Drive 读取上次录音转文字和上次学情反馈，省去教师手动复制粘贴。

**文件搜索逻辑**：根据学生姓名/班号 + 课次规则，构建预期文件名，在 Drive 中搜索。

### 2. 三级搜索兜底（V109）

**问题**：文件名格式不统一（有空格/无空格、日期/课次、"班"字有无等），精确路径搜索经常找不到文件。

**方案**：
1. 精确路径搜索：根据预期路径直接定位
2. 目录搜索：在预期目录下遍历，模糊匹配文件名
3. 全局搜索：在整个 Drive 中按关键词搜索

三级依次尝试，找到即返回。

**教训**：用户的文件组织方式永远比你预期的更多样，搜索策略必须有降级方案。

### 3. Drive API 统一（V108-V110）

**变更**：所有 Drive 操作统一使用 OAuth API（包括读取文件内容），不再混用多种方式。

**教训**：同一个外部服务的操作应统一接口方式，混用会导致 token 管理和错误处理复杂化。

---

## 三十四、V112-V118 后台任务系统

### 1. 任务表设计（V112）

新增两张表：
```sql
-- 任务主表
CREATE TABLE tasks (
  id INT AUTO_INCREMENT PRIMARY KEY,
  task_type VARCHAR(50),        -- 'one-on-one' / 'small-class' / 'batch'
  status VARCHAR(20),           -- 'running' / 'completed' / 'failed' / 'stopped'
  input_params MEDIUMTEXT,      -- JSON: 输入参数快照
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

-- 步骤详情表
CREATE TABLE task_steps (
  id INT AUTO_INCREMENT PRIMARY KEY,
  task_id INT,
  step_name VARCHAR(100),
  status VARCHAR(20),
  result MEDIUMTEXT,            -- JSON: 步骤结果
  error_message TEXT,
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);
```

**设计原则**：input_params 保存完整的输入快照，步骤结果也完整保存，方便事后排查和重试。

### 2. 数据库字段升级 mediumtext（V113）

**问题**：MySQL 的 TEXT 类型最大 65,535 字节（约 64KB），长文本（如完整录音转文字 + AI 输出）经常超限导致截断。

**解决**：input_params、step_results、system_config.value 统一升级为 MEDIUMTEXT（最大 16MB）。

**教训**：设计数据库时就要考虑最大数据量，TEXT 对中文应用来说往往不够用。

### 3. 并发数调整（V118）

**变更**：批量处理默认并发数从 5 改为 50，经实测 DMXapi 在 50 并发下稳定运行。并发数持久化到 system_config 表。

---

## 三十五、V119-V128 用户体验与非流式改造

### 1. 非流式调用改造（V122-V125）

**背景**：SSE 流式调用的 token 上限受到连接稳定性限制，且 SSE 传输大内容不可靠（V68-V71 的教训）。

**改造范围**：
- V122：后台任务改非流式
- V123：气泡图改非流式
- V125：小班课AI调用也改非流式
- V133：一对一也改非流式

**收益**：
- token 上限更大（不受 SSE 超时限制）
- 连接更稳定（不用维护长连接）
- 代码更简单（不用处理流式事件）

**教训**：流式输出看起来酷（实时显示），但非流式在稳定性和上限上更优。除非用户确实需要看到实时生成过程，否则优先用非流式。

### 2. 截断自动续写（V122）

**问题**：AI 输出经常在接近 token 上限时被截断，生成不完整的文档。

**方案**：检测到 `stop_reason === 'max_tokens'` 时，自动发起续写请求，将已生成内容作为上下文让 AI 继续。

**教训**：截断检测必须检查 stop_reason，不能只看内容长度。

### 3. SVG字体注入破坏XML（V124）

**问题**：为解决气泡图中文显示，往 SVG 中注入 CSS @font-face 声明，但注入的内容破坏了 XML 结构，导致 sharp 转换失败。

**原因**：CSS 中的特殊字符（如 `<`、`&`）在 XML 中是非法的，注入时没有转义。

**教训**：往 XML 格式（包括 SVG）中注入内容时，必须确保内容是 XML 合法的。

---

## 三十六、V129-V134 气泡图渲染引擎重构

### 1. 中文乱码问题完整攻坚史

| 版本 | 方案 | 结果 |
|------|------|------|
| V42 | 前端Canvas渲染 | 部分解决 |
| V114 | 服务端SVG字体注入 | 不稳定 |
| V124 | 修复SVG字体注入XML结构 | 仍有问题 |
| V126 | 增强字体注入 + docx微软雅黑 | 仍有乱码 |
| V129 | 换resvg引擎 | 彻底解决 |
| V130 | 显式字体路径 | 沙箱下空白 |
| V131 | 项目本地fonts/目录 | 中文正常 |
| V134 | 升级Noto Sans CJK字体 | 更美观 |

**根因链**：中文方块 → sharp依赖系统librsvg → librsvg找不到中文字体 → 换resvg（纯Rust，字体加载可控）→ 沙箱访问不了/usr/share/fonts → 复制字体到项目目录。

**教训**：底层依赖的字体处理能力决定了上层应用的中文支持，补丁式修复（注入CSS、指定路径等）不如换一个底层更可控的引擎。

### 2. resvg 使用要点

```typescript
const { Resvg } = require('@resvg/resvg-js');

// 关键：指定字体文件路径
const opts = {
  font: {
    fontFiles: [
      path.join(__dirname, '../fonts/NotoSansCJKsc-Regular.otf'),  // 优先
      path.join(__dirname, '../fonts/wqy-zenhei.ttc'),              // 兜底
    ],
    loadSystemFonts: false,  // 沙箱下不加载系统字体
  },
};

const resvg = new Resvg(svgString, opts);
const pngData = resvg.render();
const pngBuffer = pngData.asPng();
```

**注意**：`loadSystemFonts: false` 在沙箱环境下必须设置，否则会尝试扫描不可访问的系统目录导致性能问题。

### 3. COLLAB.md 协作看板诞生（V131）

**背景**：V129-V131 的气泡图字体问题涉及 Claude（写代码）和 Manus（部署环境）两方协作，需要一个标准化的沟通文档。

**机制**：
- Claude 在 COLLAB.md 中写"部署任务书"（版本号、改动内容、验收标准）
- Manus 执行 merge → build → checkpoint → push
- 每个版本一个任务条目，状态标记（待部署/已部署）

**教训**：多方协作时，书面化的任务描述比口头沟通更可靠，也便于事后追溯。

---

## 三十七、V148-V152 作业管理系统技术要点

### 1. 数据库设计

```sql
-- 学生名册
CREATE TABLE hw_students (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(100) NOT NULL UNIQUE,
  plan_type ENUM('daily', 'weekly') DEFAULT 'daily',
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

-- 作业条目
CREATE TABLE hw_entries (
  id INT AUTO_INCREMENT PRIMARY KEY,
  student_name VARCHAR(100),
  raw_text MEDIUMTEXT,           -- 原始语音转文字
  ai_result MEDIUMTEXT,          -- AI结构化处理结果
  model_used VARCHAR(100),       -- 使用的AI模型
  status ENUM('pending', 'confirmed', 'failed') DEFAULT 'pending',
  supplementary_notes TEXT,      -- 补充说明
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);
```

**设计决策**：
- hw_students 的 name 设 UNIQUE，删除用 is_active=false 软删除
- hw_entries 的 student_name 是冗余字段（非外键），简化查询
- status 用枚举：pending（预入库）→ confirmed（已入库）→ failed（处理失败可重试）

### 2. Drizzle ORM 字段命名陷阱（V150）

**问题**：updateStudent 使用了 plan_type（snake_case），但 Drizzle schema 中定义为 planType（camelCase），导致更新失败但不报错。

**原因**：Drizzle ORM 在 schema 定义中使用 camelCase 作为 JavaScript 属性名，但底层 SQL 使用 snake_case。在构建 update 对象时必须使用 camelCase。

**教训**：Drizzle 的字段命名约定：
- Schema 定义：`planType: varchar('plan_type', ...)`
- JavaScript 代码中：用 `planType`
- SQL 中：用 `plan_type`

### 3. 已删除学生重新激活（V150）

**问题**：添加学生时如果同名学生已存在但 is_active=false，INSERT 会报 UNIQUE 约束错误。

**方案**：先查询是否存在同名 inactive 学生，存在则 UPDATE is_active=true，不存在才 INSERT。
```typescript
const existing = await db.select().from(hwStudents)
  .where(eq(hwStudents.name, name)).limit(1);
if (existing.length > 0 && !existing[0].isActive) {
  await db.update(hwStudents).set({ isActive: true }).where(eq(hwStudents.id, existing[0].id));
} else {
  await db.insert(hwStudents).values({ name });
}
```

### 4. 课后信息→作业管理导入链路（V149/V152）

**流程**：
1. 课堂反馈步骤4（课后信息提取）完成
2. 用户点击「导入作业管理」按钮
3. 系统调用 homework.importFromExtraction API
4. 自动从 displayName 提取学生姓名
5. 如学生不存在则自动创建（hw_students）
6. 创建 hw_entries 条目（status=pending）
7. 用户在作业管理Tab中查看并确认入库

V152 在 TaskHistory 页面也添加了同样的导入按钮，入口更多但逻辑统一。

---

## 三十八、V66-V152 踩坑记录汇总

### 1. res.flush() 不存在（V68.2）

- **问题**：compression 中间件未启用时 `res.flush()` 不存在
- **修复**：使用可选链或类型检查

### 2. Git checkpoint rebase 覆盖历史（V63.7）

- **问题**：Manus checkpoint 机制使用 rebase，覆盖了 git log 中 V1-V140 的 commit 记录
- **影响**：git log 只保留 V141 之后的约 50 条 commit
- **发现**：git reflog 仍完整保留 574 条记录（reflog 不受 rebase 影响）
- **教训**：了解 CI/CD 工具的版本管理行为，reflog 是恢复历史的最后手段

### 3. Zod schema 丢弃未声明字段（V137）

- **问题**：学生名持久化失败，因为 Zod schema 验证会默认丢弃未声明的字段
- **修复**：在 Zod schema 中添加 students 字段声明
- **教训**：新增字段时必须同步更新所有相关的 Zod schema

### 4. ESM 环境 require() 崩溃（V128）

- **问题**：`require('sharp')` 在 ESM 模块中直接崩溃（不是报错，是进程退出）
- **修复**：移除 require(sharp)，改用动态 import
- **教训**：ESM 和 CommonJS 的混用是定时炸弹，尽量统一模块系统

### 5. Drizzle camelCase vs snake_case（V150）

- **问题**：updateStudent 用了 plan_type 而非 planType，更新静默失败
- **教训**：Drizzle 代码中永远用 camelCase

### 6. UNIQUE 约束 vs 软删除（V150）

- **问题**：添加已软删除的同名学生报错
- **教训**：软删除+UNIQUE约束需要特殊处理，先查再决定 INSERT 还是 UPDATE

---

## 三十九、V66-V152 自检清单

### SSE/传输验收

- [ ] 大内容通过 HTTP 拉取而非 SSE 传输
- [ ] contentStore 有上限保护（500条）
- [ ] 前端正确处理 SSE 事件通知 + HTTP 数据拉取

### 气泡图验收

- [ ] resvg 引擎生成气泡图
- [ ] 中文字符正常显示（不是方块）
- [ ] fonts/ 目录包含 NotoSansCJKsc 或 wqy-zenhei
- [ ] loadSystemFonts 设为 false

### Google Drive 验收

- [ ] 自动提取录音转文字正常
- [ ] 自动提取上次反馈正常
- [ ] 三级搜索（精确→目录→全局）正常
- [ ] OAuth token 并发刷新不冲突

### 后台任务验收

- [ ] 任务记录正确保存到数据库
- [ ] 非流式调用正常
- [ ] 截断自动续写触发正确
- [ ] 停止按钮功能正常
- [ ] 任务记录显示模型名称

### 作业管理验收

- [ ] 学生名册增删改查正常
- [ ] 日计划/周计划切换保存正常
- [ ] AI结构化处理正常
- [ ] 预入库→确认入库流程正常
- [ ] 已入库记录按时间倒序显示
- [ ] 课后信息导入正常（V149）
- [ ] 任务记录导入正常（V152）
- [ ] 已删除学生重新添加能激活（V150）

---

## 三十九、V172-V179 多租户隔离深度修复

### 1. getConfigValue 跨租户 fallback 问题（V176）

**问题**：`getConfigValue(key, userId)` 在 user_config 找不到数据时 fallback 到 systemConfig，导致所有用户都能看到 admin（owner）的路书、存储路径、API 配置等敏感信息。

**根因**：最初设计时 fallback 是为了"向后兼容"——旧系统没有 user_config，新系统上线后用户还没配置自己的值，fallback 让系统能继续工作。但这违反了隔离原则。

**修复**：
```typescript
if (userId != null) {
  // 仅查 user_config，不穿透到 systemConfig
  const result = await db.select().from(userConfig)
    .where(and(eq(userConfig.userId, userId), eq(userConfig.key, key)));
  if (result.length > 0) return result[0].value;
  return DEFAULT_CONFIG[key] || "";  // 返回默认值，不查 systemConfig
}
```

**教训**：多租户系统中**绝对不能跨租户 fallback**。"向后兼容"不能以牺牲隔离性为代价。

### 2. migrateSystemConfigToAdmin 范围失控（V178）

**问题**：`migrateSystemConfigToAdmin` 对所有 `role='admin'` 的用户执行，在 config.getAll 中每次请求都触发。当系统有多个 admin 时，owner 的 systemConfig 数据（路书、路径、API密钥、学生历史）全部被复制到其他 admin 的 user_config 中。

**修复**：仅对 `ctx.user.openId === ENV.ownerOpenId` 的用户执行迁移。

**教训**：一次性数据迁移必须精确限定执行对象。"admin 角色"不等于"数据原始 owner"。

### 3. exportBackup 数据泄露（V178）

**问题**：备份导出接口读取 systemConfig 作为 fallback，mergedConfig 包含了其他用户的配置数据。

**修复**：备份仅包含当前用户的 user_config + DEFAULT_CONFIG 填充缺失值。

### 4. localStorage 跨账户污染（V175）

**问题**：前端 localStorage 的 key 用 `userId || 'default'` 做兜底。当 `useAuth()` 首次渲染返回 null 时，所有用户都读写 `student_lesson_history_default` 这个 key，导致学生列表跨账户共享。

**修复**：userId 为空时直接返回空数据，不做 fallback。

**教训**：任何涉及用户数据的 key 都不能有"公共默认值"。

### 5. config.update 权限过严（V179）

**问题**：config.update 是 adminProcedure，非管理员用户打开设置页面后无法保存。但所有配置都写入 user_config（按 userId 隔离），没有理由限制。

**修复**：改为 protectedProcedure。

### 多租户隔离验收清单

- [x] getConfigValue 有 userId 时不 fallback 到 systemConfig
- [x] migrateSystemConfigToAdmin 仅对 owner 执行
- [x] exportBackup 不包含 systemConfig 数据
- [x] localStorage key 包含 userId，无 "default" 回退
- [x] config.update / config.reset 为 protectedProcedure
- [x] 路径输入框默认值用 placeholder 灰色显示
- [x] 230+ 项租户隔离测试全部通过

---

*文档更新时间：2026年2月16日*
*当前版本：V179*
